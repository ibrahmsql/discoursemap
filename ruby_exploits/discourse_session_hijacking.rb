#!/usr/bin/env ruby
# Discourse Session Hijacking and Manipulation Exploits
# This script tests for session-related vulnerabilities in Discourse forums

require 'net/http'
require 'uri'
require 'json'
require 'openssl'
require 'base64'

class DiscourseSessionHijacking
  def initialize(target_url, options = {})
    @target_url = target_url.chomp('/')
    @timeout = options[:timeout] || 10
    @user_agent = options[:user_agent] || 'Mozilla/5.0 (compatible; DiscourseSessionTester/1.0)'
    @verbose = options[:verbose] || false
    @results = []
  end

  def run_all_tests
    puts "[*] Starting Discourse Session Hijacking Tests on #{@target_url}"
    
    test_session_fixation
    test_session_prediction
    test_weak_session_tokens
    test_session_timeout
    test_concurrent_sessions
    test_session_cookie_security
    test_csrf_token_reuse
    test_remember_me_vulnerabilities
    
    generate_report
  end

  private

  def test_session_fixation
    puts "[*] Testing for Session Fixation vulnerabilities..."
    
    begin
      # Get initial session
      uri = URI("#{@target_url}/session/csrf")
      response = make_request(uri)
      
      if response && response.code == '200'
        # Extract session cookie
        session_cookie = extract_session_cookie(response)
        csrf_token = extract_csrf_token(response.body)
        
        if session_cookie
          # Try to login with fixed session
          login_data = {
            'login' => 'testuser',
            'password' => 'testpass',
            'authenticity_token' => csrf_token
          }
          
          login_response = make_post_request("#{@target_url}/session", login_data, session_cookie)
          
          if login_response && login_response.code == '200'
            new_session = extract_session_cookie(login_response)
            
            if session_cookie == new_session
              add_vulnerability({
                type: 'Session Fixation',
                severity: 'High',
                description: 'Session ID does not change after authentication',
                endpoint: '/session',
                evidence: "Original session: #{session_cookie}, Post-login session: #{new_session}"
              })
            end
          end
        end
      end
    rescue => e
      puts "[!] Error in session fixation test: #{e.message}" if @verbose
    end
  end

  def test_session_prediction
    puts "[*] Testing for Session Token Predictability..."
    
    sessions = []
    
    # Collect multiple session tokens
    5.times do |i|
      begin
        uri = URI("#{@target_url}/session/csrf")
        response = make_request(uri)
        
        if response && response.code == '200'
          session_cookie = extract_session_cookie(response)
          sessions << session_cookie if session_cookie
        end
        
        sleep(0.5)
      rescue => e
        puts "[!] Error collecting session #{i}: #{e.message}" if @verbose
      end
    end
    
    if sessions.length >= 3
      # Analyze session patterns
      if analyze_session_patterns(sessions)
        add_vulnerability({
          type: 'Predictable Session Tokens',
          severity: 'Critical',
          description: 'Session tokens follow predictable patterns',
          endpoint: '/session/csrf',
          evidence: "Sample sessions: #{sessions.first(3).join(', ')}"
        })
      end
    end
  end

  def test_weak_session_tokens
    puts "[*] Testing for Weak Session Token Generation..."
    
    begin
      uri = URI("#{@target_url}/session/csrf")
      response = make_request(uri)
      
      if response && response.code == '200'
        session_cookie = extract_session_cookie(response)
        
        if session_cookie
          # Analyze token strength
          if analyze_token_strength(session_cookie)
            add_vulnerability({
              type: 'Weak Session Token',
              severity: 'Medium',
              description: 'Session token has insufficient entropy or weak generation',
              endpoint: '/session/csrf',
              evidence: "Session token: #{session_cookie}"
            })
          end
        end
      end
    rescue => e
      puts "[!] Error in weak session token test: #{e.message}" if @verbose
    end
  end

  def test_session_timeout
    puts "[*] Testing Session Timeout Configuration..."
    
    begin
      # Login and get session
      login_data = {
        'login' => 'testuser',
        'password' => 'testpass'
      }
      
      response = make_post_request("#{@target_url}/session", login_data)
      
      if response
        session_cookie = extract_session_cookie(response)
        
        if session_cookie
          # Test if session persists after extended time
          sleep(2) # Simulate time passage
          
          # Try to access protected resource
          protected_response = make_request(URI("#{@target_url}/my/preferences"), session_cookie)
          
          if protected_response && protected_response.code == '200'
            # Check if session timeout is configured
            if !check_session_timeout_headers(protected_response)
              add_vulnerability({
                type: 'Missing Session Timeout',
                severity: 'Low',
                description: 'Session timeout not properly configured',
                endpoint: '/my/preferences',
                evidence: 'No session timeout headers found'
              })
            end
          end
        end
      end
    rescue => e
      puts "[!] Error in session timeout test: #{e.message}" if @verbose
    end
  end

  def test_concurrent_sessions
    puts "[*] Testing Concurrent Session Handling..."
    
    begin
      sessions = []
      
      # Create multiple sessions for same user
      3.times do
        login_data = {
          'login' => 'testuser',
          'password' => 'testpass'
        }
        
        response = make_post_request("#{@target_url}/session", login_data)
        
        if response
          session_cookie = extract_session_cookie(response)
          sessions << session_cookie if session_cookie
        end
      end
      
      if sessions.length > 1
        # Test if all sessions are valid
        valid_sessions = 0
        
        sessions.each do |session|
          test_response = make_request(URI("#{@target_url}/my/preferences"), session)
          valid_sessions += 1 if test_response && test_response.code == '200'
        end
        
        if valid_sessions > 1
          add_vulnerability({
            type: 'Concurrent Session Vulnerability',
            severity: 'Medium',
            description: 'Multiple concurrent sessions allowed for same user',
            endpoint: '/session',
            evidence: "#{valid_sessions} concurrent sessions active"
          })
        end
      end
    rescue => e
      puts "[!] Error in concurrent session test: #{e.message}" if @verbose
    end
  end

  def test_session_cookie_security
    puts "[*] Testing Session Cookie Security Attributes..."
    
    begin
      uri = URI("#{@target_url}/session/csrf")
      response = make_request(uri)
      
      if response && response.code == '200'
        cookies = response.get_fields('set-cookie')
        
        if cookies
          cookies.each do |cookie|
            if cookie.include?('_discourse_session') || cookie.include?('session')
              issues = []
              
              issues << 'Missing Secure flag' unless cookie.include?('Secure')
              issues << 'Missing HttpOnly flag' unless cookie.include?('HttpOnly')
              issues << 'Missing SameSite attribute' unless cookie.include?('SameSite')
              
              if issues.any?
                add_vulnerability({
                  type: 'Insecure Session Cookie',
                  severity: 'Medium',
                  description: 'Session cookie missing security attributes',
                  endpoint: '/session/csrf',
                  evidence: "Issues: #{issues.join(', ')}. Cookie: #{cookie}"
                })
              end
            end
          end
        end
      end
    rescue => e
      puts "[!] Error in session cookie security test: #{e.message}" if @verbose
    end
  end

  def test_csrf_token_reuse
    puts "[*] Testing CSRF Token Reuse Vulnerabilities..."
    
    begin
      # Get CSRF token
      uri = URI("#{@target_url}/session/csrf")
      response = make_request(uri)
      
      if response && response.code == '200'
        csrf_token = extract_csrf_token(response.body)
        
        if csrf_token
          # Try to reuse CSRF token multiple times
          3.times do |i|
            test_data = {
              'authenticity_token' => csrf_token,
              'test_action' => "test_#{i}"
            }
            
            reuse_response = make_post_request("#{@target_url}/session", test_data)
            
            if reuse_response && reuse_response.code == '200'
              add_vulnerability({
                type: 'CSRF Token Reuse',
                severity: 'Medium',
                description: 'CSRF token can be reused multiple times',
                endpoint: '/session',
                evidence: "Token reused #{i + 1} times successfully"
              })
              break
            end
          end
        end
      end
    rescue => e
      puts "[!] Error in CSRF token reuse test: #{e.message}" if @verbose
    end
  end

  def test_remember_me_vulnerabilities
    puts "[*] Testing Remember Me Token Vulnerabilities..."
    
    begin
      # Test remember me functionality
      login_data = {
        'login' => 'testuser',
        'password' => 'testpass',
        'remember_me' => '1'
      }
      
      response = make_post_request("#{@target_url}/session", login_data)
      
      if response
        cookies = response.get_fields('set-cookie')
        
        if cookies
          remember_token = nil
          
          cookies.each do |cookie|
            if cookie.include?('remember') || cookie.include?('persistent')
              remember_token = cookie
              break
            end
          end
          
          if remember_token
            # Analyze remember token
            if analyze_remember_token(remember_token)
              add_vulnerability({
                type: 'Weak Remember Me Token',
                severity: 'Medium',
                description: 'Remember me token has security weaknesses',
                endpoint: '/session',
                evidence: "Remember token: #{remember_token}"
              })
            end
          end
        end
      end
    rescue => e
      puts "[!] Error in remember me test: #{e.message}" if @verbose
    end
  end

  # Helper methods
  def make_request(uri, session_cookie = nil)
    http = Net::HTTP.new(uri.host, uri.port)
    http.use_ssl = uri.scheme == 'https'
    http.verify_mode = OpenSSL::SSL::VERIFY_NONE if http.use_ssl?
    http.read_timeout = @timeout
    
    request = Net::HTTP::Get.new(uri)
    request['User-Agent'] = @user_agent
    request['Cookie'] = session_cookie if session_cookie
    
    http.request(request)
  rescue => e
    puts "[!] Request failed: #{e.message}" if @verbose
    nil
  end

  def make_post_request(url, data, session_cookie = nil)
    uri = URI(url)
    http = Net::HTTP.new(uri.host, uri.port)
    http.use_ssl = uri.scheme == 'https'
    http.verify_mode = OpenSSL::SSL::VERIFY_NONE if http.use_ssl?
    http.read_timeout = @timeout
    
    request = Net::HTTP::Post.new(uri)
    request['User-Agent'] = @user_agent
    request['Content-Type'] = 'application/x-www-form-urlencoded'
    request['Cookie'] = session_cookie if session_cookie
    request.body = URI.encode_www_form(data)
    
    http.request(request)
  rescue => e
    puts "[!] POST request failed: #{e.message}" if @verbose
    nil
  end

  def extract_session_cookie(response)
    cookies = response.get_fields('set-cookie')
    return nil unless cookies
    
    cookies.each do |cookie|
      if cookie.include?('_discourse_session') || cookie.include?('session')
        return cookie.split(';').first
      end
    end
    
    nil
  end

  def extract_csrf_token(body)
    # Try to extract CSRF token from response
    if body.include?('csrf-token')
      match = body.match(/csrf-token["']?\s*content=["']([^"']+)["']/)
      return match[1] if match
    end
    
    # Try meta tag
    match = body.match(/<meta name=["']csrf-token["'] content=["']([^"']+)["']/)
    return match[1] if match
    
    # Try JSON response
    begin
      json = JSON.parse(body)
      return json['csrf'] || json['authenticity_token']
    rescue
      # Not JSON
    end
    
    nil
  end

  def analyze_session_patterns(sessions)
    return false if sessions.length < 3
    
    # Check for sequential patterns
    numeric_parts = sessions.map do |session|
      session.scan(/\d+/).join.to_i
    end
    
    # Check if sessions are sequential
    differences = []
    (1...numeric_parts.length).each do |i|
      differences << (numeric_parts[i] - numeric_parts[i-1]).abs
    end
    
    # If differences are consistent, sessions might be predictable
    differences.uniq.length <= 2
  end

  def analyze_token_strength(token)
    # Check token length
    return true if token.length < 16
    
    # Check for only numeric tokens
    return true if token.match?(/^\d+$/)
    
    # Check for simple patterns
    return true if token.match?(/^[a-f0-9]+$/) && token.length < 32
    
    # Check entropy (simplified)
    unique_chars = token.chars.uniq.length
    return true if unique_chars < 8
    
    false
  end

  def check_session_timeout_headers(response)
    headers = response.to_hash
    
    # Check for session timeout related headers
    timeout_headers = ['cache-control', 'expires', 'pragma']
    
    timeout_headers.any? do |header|
      headers[header] && headers[header].any? { |value| value.include?('no-cache') || value.include?('no-store') }
    end
  end

  def analyze_remember_token(token)
    # Extract token value
    token_value = token.split('=')[1]&.split(';')&.first
    return false unless token_value
    
    # Check if token is too simple
    return true if token_value.length < 32
    
    # Check if token is base64 encoded timestamp (common weakness)
    begin
      decoded = Base64.decode64(token_value)
      return true if decoded.match?(/^\d{10,}$/)
    rescue
      # Not base64
    end
    
    # Check for missing security attributes
    return true unless token.include?('HttpOnly')
    return true unless token.include?('Secure')
    
    false
  end

  def add_vulnerability(vuln)
    @results << vuln
    puts "[!] #{vuln[:type]}: #{vuln[:description]}"
  end

  def generate_report
    puts "\n" + "="*60
    puts "DISCOURSE SESSION HIJACKING TEST REPORT"
    puts "="*60
    puts "Target: #{@target_url}"
    puts "Timestamp: #{Time.now}"
    puts "Total Vulnerabilities Found: #{@results.length}"
    puts "-"*60
    
    if @results.empty?
      puts "[+] No session-related vulnerabilities detected."
    else
      @results.group_by { |v| v[:severity] }.each do |severity, vulns|
        puts "\n#{severity.upcase} SEVERITY (#{vulns.length}):"
        vulns.each_with_index do |vuln, index|
          puts "  #{index + 1}. #{vuln[:type]}"
          puts "     Description: #{vuln[:description]}"
          puts "     Endpoint: #{vuln[:endpoint]}" if vuln[:endpoint]
          puts "     Evidence: #{vuln[:evidence]}" if vuln[:evidence]
          puts
        end
      end
    end
    
    puts "="*60
  end
end

# Usage example
if __FILE__ == $0
  if ARGV.length < 1
    puts "Usage: ruby discourse_session_hijacking.rb <target_url> [options]"
    puts "Example: ruby discourse_session_hijacking.rb https://forum.example.com"
    exit 1
  end
  
  target_url = ARGV[0]
  options = {
    verbose: ARGV.include?('--verbose') || ARGV.include?('-v'),
    timeout: 15
  }
  
  tester = DiscourseSessionHijacking.new(target_url, options)
  tester.run_all_tests
end